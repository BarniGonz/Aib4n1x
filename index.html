<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot with Photo Analysis & Advanced Memory - Powered by Barni</title>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, doc, getDoc, setDoc, updateDoc, query, where, getDocs, deleteDoc, Timestamp, serverTimestamp, onSnapshot } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail, updateProfile, sendEmailVerification } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCmDLSB0S_0qnrcl5tsaSVyRQaopy8M12I",
      authDomain: "aib4n1x.firebaseapp.com",
      projectId: "aib4n1x",
      storageBucket: "aib4n1x.firebasestorage.app",
      messagingSenderId: "318019512167",
      appId: "1:318019512167:web:9dae7a6654bf7a9fbd31c2",
      measurementId: "G-4W0QEKN332"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // Enhanced Device Registration & Session Management System
    class DeviceSessionManager {
      constructor() {
        this.deviceID = null;
        this.sessionToken = null;
        this.currentUser = null;
        this.userDeviceDoc = null;
        this.isDeviceAuthorized = false;
        this.deviceFingerprint = null;
        this.sessionExpiryTime = null;
        this.generateDeviceFingerprint();
        this.initializeDeviceID();
      }

      generateDeviceFingerprint() {
        // Create comprehensive device fingerprint
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillText('Device fingerprint test', 2, 2);

        const fingerprint = btoa(JSON.stringify({
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          language: navigator.language,
          languages: navigator.languages?.slice(0, 3),
          screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          cookieEnabled: navigator.cookieEnabled,
          doNotTrack: navigator.doNotTrack,
          canvas: canvas.toDataURL().slice(0, 50),
          timestamp: Date.now(),
          version: 'device_v2'
        }));

        this.deviceFingerprint = fingerprint;
        console.log('Device fingerprint generated:', fingerprint.slice(0, 20) + '...');
      }

      initializeDeviceID() {
        // Try to get existing device ID from storage
        this.deviceID = this.getStoredDeviceID();
        
        if (!this.deviceID) {
          // Generate new device ID
          this.deviceID = this.generateDeviceID();
          this.storeDeviceID();
        }

        console.log('Device ID initialized:', this.deviceID.slice(0, 8) + '...');
      }

      generateDeviceID() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substr(2, 9);
        const fingerprint = this.deviceFingerprint.slice(-8);
        return `dev_${timestamp}_${random}_${fingerprint}`;
      }

      getStoredDeviceID() {
        const storageKeys = [
          'firebase_device_id_persistent_v2',
          'firebase_device_id_backup_v2',
          'firebase_device_id_emergency_v2'
        ];

        for (const key of storageKeys) {
          try {
            const stored = localStorage.getItem(key) || sessionStorage.getItem(key);
            if (stored) {
              const data = JSON.parse(stored);
              if (data.deviceID && data.fingerprint === this.deviceFingerprint) {
                return data.deviceID;
              }
            }
          } catch (e) {
            continue;
          }
        }

        return null;
      }

      storeDeviceID() {
        const deviceData = {
          deviceID: this.deviceID,
          fingerprint: this.deviceFingerprint,
          created: Date.now(),
          version: 'v2'
        };

        const serialized = JSON.stringify(deviceData);

        try {
          localStorage.setItem('firebase_device_id_persistent_v2', serialized);
          localStorage.setItem('firebase_device_id_backup_v2', serialized);
          sessionStorage.setItem('firebase_device_id_emergency_v2', serialized);
        } catch (e) {
          console.warn('Failed to store device ID:', e);
        }
      }

      async registerDeviceForUser(user) {
        if (!user || !user.uid) {
          throw new Error('Valid user required for device registration');
        }

        this.currentUser = user;
        const userDeviceRef = doc(db, 'user_devices', user.uid);

        try {
          // Check existing device registration
          const existingDoc = await getDoc(userDeviceRef);
          
          if (existingDoc.exists()) {
            const data = existingDoc.data();
            
            // Check if same device
            if (data.deviceID === this.deviceID && data.deviceFingerprint === this.deviceFingerprint) {
              // Same device - update session
              await this.updateDeviceSession(userDeviceRef, user);
              this.isDeviceAuthorized = true;
              return { success: true, message: 'Device session restored' };
            } else {
              // Different device - block login
              this.isDeviceAuthorized = false;
              throw new Error('DEVICE_LIMIT_EXCEEDED');
            }
          } else {
            // New device registration
            await this.createDeviceRegistration(userDeviceRef, user);
            this.isDeviceAuthorized = true;
            return { success: true, message: 'Device registered successfully' };
          }
        } catch (error) {
          console.error('Device registration error:', error);
          
          if (error.message === 'DEVICE_LIMIT_EXCEEDED') {
            throw error;
          }
          
          throw new Error('Device registration failed');
        }
      }

      async createDeviceRegistration(userDeviceRef, user) {
        this.sessionToken = this.generateSessionToken();
        this.sessionExpiryTime = Date.now() + (30 * 24 * 60 * 60 * 1000); // 30 days

        const deviceData = {
          deviceID: this.deviceID,
          deviceFingerprint: this.deviceFingerprint,
          userEmail: user.email,
          userUID: user.uid,
          sessionToken: this.sessionToken,
          sessionExpiryTime: this.sessionExpiryTime,
          registeredAt: serverTimestamp(),
          lastAccess: serverTimestamp(),
          ipAddress: await this.getIPAddress(),
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          isActive: true,
          version: 'device_v2'
        };

        await setDoc(userDeviceRef, deviceData);
        this.userDeviceDoc = deviceData;
        console.log('New device registered for user:', user.email);
      }

      async updateDeviceSession(userDeviceRef, user) {
        this.sessionToken = this.generateSessionToken();
        this.sessionExpiryTime = Date.now() + (30 * 24 * 60 * 60 * 1000); // 30 days

        const updateData = {
          sessionToken: this.sessionToken,
          sessionExpiryTime: this.sessionExpiryTime,
          lastAccess: serverTimestamp(),
          ipAddress: await this.getIPAddress(),
          isActive: true
        };

        await updateDoc(userDeviceRef, updateData);
        console.log('Device session updated for user:', user.email);
      }

      generateSessionToken() {
        return btoa(Math.random().toString(36) + Date.now().toString(36) + this.deviceID);
      }

      async getIPAddress() {
        try {
          const response = await fetch('https://api.ipify.org?format=json');
          const data = await response.json();
          return data.ip;
        } catch (e) {
          return 'unknown';
        }
      }

      async unregisterDevice(user) {
        if (!user || !user.uid) return;

        try {
          const userDeviceRef = doc(db, 'user_devices', user.uid);
          await updateDoc(userDeviceRef, {
            isActive: false,
            unregisteredAt: serverTimestamp()
          });

          this.isDeviceAuthorized = false;
          this.currentUser = null;
          this.userDeviceDoc = null;
          this.sessionToken = null;
          
          console.log('Device unregistered for user:', user.email);
        } catch (error) {
          console.error('Device unregistration error:', error);
        }
      }

      async validateSession() {
        if (!this.currentUser || !this.sessionToken) {
          return false;
        }

        try {
          const userDeviceRef = doc(db, 'user_devices', this.currentUser.uid);
          const deviceDoc = await getDoc(userDeviceRef);

          if (!deviceDoc.exists()) {
            return false;
          }

          const data = deviceDoc.data();
          
          // Validate session
          if (data.sessionToken !== this.sessionToken ||
              data.deviceID !== this.deviceID ||
              data.sessionExpiryTime < Date.now() ||
              !data.isActive) {
            return false;
          }

          return true;
        } catch (error) {
          console.error('Session validation error:', error);
          return false;
        }
      }

      getDeviceInfo() {
        return {
          deviceID: this.deviceID,
          fingerprint: this.deviceFingerprint.slice(0, 20) + '...',
          authorized: this.isDeviceAuthorized,
          sessionValid: !!this.sessionToken
        };
      }
    }

    // Enhanced Authentication Manager
    class EnhancedAuthManager {
      constructor() {
        this.deviceManager = new DeviceSessionManager();
        this.currentUser = null;
        this.isAuthenticated = false;
        this.authListenersInitialized = false;
        this.userProfile = null;
        this.initializeAuthListener();
      }

      initializeAuthListener() {
        onAuthStateChanged(auth, async (user) => {
          if (user) {
            console.log('Firebase user detected:', user.email);
            
            // Always check device authorization
            try {
              const deviceResult = await this.deviceManager.registerDeviceForUser(user);
              
              if (deviceResult.success) {
                this.currentUser = user;
                this.isAuthenticated = true;
                await this.loadUserProfile(user);
                this.hideAuthUI();
                window.dispatchEvent(new CustomEvent('userAuthenticated', { 
                  detail: { 
                    user: user, 
                    deviceInfo: this.deviceManager.getDeviceInfo() 
                  } 
                }));
                console.log('User authenticated successfully:', user.email);
              }
            } catch (error) {
              if (error.message === 'DEVICE_LIMIT_EXCEEDED') {
                this.handleDeviceLimitExceeded();
              } else {
                console.error('Device registration failed:', error);
                await this.signOut();
              }
            }
          } else {
            console.log('No authenticated user');
            this.currentUser = null;
            this.isAuthenticated = false;
            this.showAuthUI();
          }
        });
      }

      async loadUserProfile(user) {
        try {
          const userProfileRef = doc(db, 'user_profiles', user.uid);
          const profileDoc = await getDoc(userProfileRef);
          
          if (profileDoc.exists()) {
            this.userProfile = profileDoc.data();
          } else {
            // Create new profile
            this.userProfile = {
              email: user.email,
              displayName: user.displayName || user.email.split('@')[0],
              createdAt: serverTimestamp(),
              lastLogin: serverTimestamp(),
              emailVerified: user.emailVerified,
              loginCount: 1
            };
            
            await setDoc(userProfileRef, this.userProfile);
          }
          
          // Update last login
          await updateDoc(userProfileRef, {
            lastLogin: serverTimestamp(),
            loginCount: (this.userProfile.loginCount || 0) + 1,
            emailVerified: user.emailVerified
          });
          
        } catch (error) {
          console.error('Error loading user profile:', error);
          this.userProfile = { email: user.email, displayName: user.email.split('@')[0] };
        }
      }

      async signIn(email, password) {
        try {
          if (!email || !password) {
            throw new Error('Email and password are required');
          }

          this.showAuthStatus('Signing in...', 'info');

          const userCredential = await signInWithEmailAndPassword(auth, email, password);
          const user = userCredential.user;

          if (!user.emailVerified) {
            await this.sendEmailVerification(user);
            throw new Error('Please verify your email address. Check your inbox for verification link.');
          }

          // Device registration happens in onAuthStateChanged
          return { success: true, user: user };

        } catch (error) {
          console.error('Sign-in error:', error);
          let message = 'Sign-in failed';
          
          switch (error.code) {
            case 'auth/user-not-found':
              message = 'No account found with this email address';
              break;
            case 'auth/wrong-password':
              message = 'Incorrect password';
              break;
            case 'auth/invalid-email':
              message = 'Invalid email address format';
              break;
            case 'auth/user-disabled':
              message = 'This account has been disabled';
              break;
            case 'auth/too-many-requests':
              message = 'Too many failed attempts. Try again later';
              break;
            default:
              message = error.message;
          }
          
          this.showAuthStatus(message, 'error');
          throw new Error(message);
        }
      }

      async signUp(email, password, confirmPassword, displayName) {
        try {
          if (!email || !password || !confirmPassword) {
            throw new Error('All fields are required');
          }

          if (password !== confirmPassword) {
            throw new Error('Passwords do not match');
          }

          if (password.length < 6) {
            throw new Error('Password must be at least 6 characters long');
          }

          // Check if user already exists
          const existingUser = await this.checkUserExists(email);
          if (existingUser) {
            throw new Error('An account with this email already exists');
          }

          this.showAuthStatus('Creating account...', 'info');

          const userCredential = await createUserWithEmailAndPassword(auth, email, password);
          const user = userCredential.user;

          // Update profile
          if (displayName) {
            await updateProfile(user, { displayName: displayName });
          }

          // Send email verification
          await this.sendEmailVerification(user);

          // Create initial user profile
          await this.createUserProfile(user, displayName);

          this.showAuthStatus('Account created! Please check your email to verify your account.', 'success');

          // Don't auto-sign in until email is verified
          await signOut(auth);

          return { success: true, user: user, requiresVerification: true };

        } catch (error) {
          console.error('Sign-up error:', error);
          let message = 'Account creation failed';

          switch (error.code) {
            case 'auth/email-already-in-use':
              message = 'An account with this email already exists';
              break;
            case 'auth/invalid-email':
              message = 'Invalid email address format';
              break;
            case 'auth/operation-not-allowed':
              message = 'Email/password accounts are not enabled';
              break;
            case 'auth/weak-password':
              message = 'Password is too weak';
              break;
            default:
              message = error.message;
          }

          this.showAuthStatus(message, 'error');
          throw new Error(message);
        }
      }

      async checkUserExists(email) {
        try {
          // Try to get user profile document
          const usersQuery = query(collection(db, 'user_profiles'), where('email', '==', email));
          const querySnapshot = await getDocs(usersQuery);
          return !querySnapshot.empty;
        } catch (error) {
          console.error('Error checking user existence:', error);
          return false;
        }
      }

      async createUserProfile(user, displayName) {
        try {
          const profileData = {
            email: user.email,
            displayName: displayName || user.email.split('@')[0],
            createdAt: serverTimestamp(),
            emailVerified: false,
            loginCount: 0,
            isActive: true
          };

          const userProfileRef = doc(db, 'user_profiles', user.uid);
          await setDoc(userProfileRef, profileData);
          
          console.log('User profile created for:', user.email);
        } catch (error) {
          console.error('Error creating user profile:', error);
        }
      }

      async sendEmailVerification(user) {
        try {
          await sendEmailVerification(user);
          console.log('Email verification sent to:', user.email);
        } catch (error) {
          console.error('Error sending email verification:', error);
        }
      }

      async resetPassword(email) {
        try {
          if (!email) {
            throw new Error('Email address is required');
          }

          this.showAuthStatus('Sending password reset email...', 'info');

          await sendPasswordResetEmail(auth, email);
          this.showAuthStatus('Password reset email sent! Check your inbox.', 'success');
          
          return { success: true };
        } catch (error) {
          console.error('Password reset error:', error);
          let message = 'Password reset failed';

          switch (error.code) {
            case 'auth/user-not-found':
              message = 'No account found with this email address';
              break;
            case 'auth/invalid-email':
              message = 'Invalid email address format';
              break;
            default:
              message = error.message;
          }

          this.showAuthStatus(message, 'error');
          throw new Error(message);
        }
      }

      async signOut() {
        try {
          if (this.currentUser) {
            await this.deviceManager.unregisterDevice(this.currentUser);
          }
          
          await signOut(auth);
          this.currentUser = null;
          this.isAuthenticated = false;
          this.userProfile = null;
          this.showAuthUI();
          
          console.log('User signed out successfully');
          return { success: true };
        } catch (error) {
          console.error('Sign-out error:', error);
          throw new Error('Sign-out failed');
        }
      }

      handleDeviceLimitExceeded() {
        this.showDeviceBlockedUI();
      }

      showAuthUI() {
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        
        if (authContainer && appContainer) {
          authContainer.style.display = 'block';
          appContainer.style.display = 'none';
        }
      }

      hideAuthUI() {
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        
        if (authContainer && appContainer) {
          authContainer.style.display = 'none';
          appContainer.style.display = 'block';
        }
      }

      showDeviceBlockedUI() {
        const blockedOverlay = document.createElement('div');
        blockedOverlay.className = 'blocked-overlay';
        blockedOverlay.innerHTML = `
          <div class="blocked-message">
            <h3>ðŸš« Device Limit Reached</h3>
            <p class="pulsing-text">This account is already active on another device.</p>
            <p style="margin: 1rem 0; font-size: 0.875rem; opacity: 0.8;">
              Only one device per account is allowed for security reasons.
            </p>
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: center;">
              <button onclick="authManager.signOut()" style="background: #dc2626; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer;">
                Sign Out
              </button>
              <button onclick="this.closest('.blocked-overlay').remove()" style="background: #6b7280; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer;">
                Close
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(blockedOverlay);
      }

      showAuthStatus(message, type = 'info') {
        const statusElement = document.getElementById('auth-status');
        if (statusElement) {
          statusElement.textContent = message;
          statusElement.className = `auth-status ${type}`;
          statusElement.style.display = 'block';
          
          if (type === 'success' || type === 'error') {
            setTimeout(() => {
              statusElement.style.display = 'none';
            }, 5000);
          }
        }
      }

      getCurrentUser() {
        return this.currentUser;
      }

      getUserProfile() {
        return this.userProfile;
      }

      getDeviceInfo() {
        return this.deviceManager.getDeviceInfo();
      }

      isUserAuthenticated() {
        return this.isAuthenticated && this.deviceManager.isDeviceAuthorized;
      }
    }

    // Initialize Enhanced Auth Manager
    const authManager = new EnhancedAuthManager();

    // Expose globals
    window.firebaseDB = db;
    window.firebaseAuth = auth;
    window.authManager = authManager;
    window.firebaseModules = {
      collection, doc, getDoc, setDoc, updateDoc, query, where, getDocs, deleteDoc, Timestamp, serverTimestamp, onSnapshot
    };

    // Signal that Firebase is ready
    window.firebaseReady = true;
    window.dispatchEvent(new Event('firebaseReady'));
  </script>

  <script src="https://js.puter.com/v2/"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" media="(prefers-color-scheme: dark)">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <style>
    :root {
      --primary-color: #6b46c1;
      --primary-dark: #553c9a;
      --background-gradient-start: #e9d5ff;
      --background-gradient-end: #c4b5fd;
      --chat-bg: rgba(255, 255, 255, 0.9);
      --chat-border: rgba(255, 255, 255, 0.2);
      --user-bg: linear-gradient(135deg, #7c3aed, #4c1d95);
      --ai-bg: linear-gradient(135deg, #e2e8f0, #cbd5e1);
      --text-color: #1f2937;
      --border-color: #d1d5db;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      --scrollbar-color: #6b46c1;
      --scrollbar-bg: #e5e7eb;
      --transition: all 0.3s ease;
      --blur: blur(8px);
      --gradient-colors: #ff6bcb, #6b46c1, #00c4ff, #ff6bcb;
      --code-bg: #f8f9fa;
      --code-border: #e9ecef;
      --topic-tag-bg: #e0e7ff;
      --topic-tag-text: #3730a3;
      --memory-bg: #f0f9ff;
      --memory-border: #0369a1;
      --related-topic-bg: #f3e8ff;
      --related-topic-text: #6d28d9;
      --toast-success: #10b981;
      --toast-error: #ef4444;
      --toast-warning: #f59e0b;
      --toast-info: #3b82f6;
      --image-preview-bg: #f3f4f6;
      --image-border: #9333ea;
      --photo-btn-bg: #7c3aed;
      --photo-btn-hover: #6d28d9;
      --key-panel-bg: #fef3c7;
      --key-panel-border: #f59e0b;
      --key-activated-bg: #d1fae5;
      --key-activated-border: #10b981;
      --key-expired-bg: #fee2e2;
      --key-expired-border: #ef4444;
      --key-deleted-bg: #1f2937;
      --key-deleted-border: #374151;
      --auth-bg: #ffffff;
      --auth-border: #e5e7eb;
      --input-bg: #ffffff;
      --input-border: #d1d5db;
      --input-focus: #6b46c1;
      --button-bg: #6b46c1;
      --button-hover: #553c9a;
      --link-color: #6b46c1;
    }

    :root[data-theme="dark"] {
      --primary-color: #a78bfa;
      --primary-dark: #7c3aed;
      --background-gradient-start: #1e1b4b;
      --background-gradient-end: #2e1065;
      --chat-bg: rgba(30, 41, 59, 0.9);
      --chat-border: rgba(255, 255, 255, 0.1);
      --user-bg: linear-gradient(135deg, #a78bfa, #7c3aed);
      --ai-bg: linear-gradient(135deg, #475569, #334155);
      --text-color: #e2e8f0;
      --border-color: #475569;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      --scrollbar-color: #a78bfa;
      --scrollbar-bg: #1e293b;
      --gradient-colors: #ff6bcb, #a78bfa, #00c4ff, #ff6bcb;
      --code-bg: #1e293b;
      --code-border: #374151;
      --topic-tag-bg: #374151;
      --topic-tag-text: #a78bfa;
      --memory-bg: #1e293b;
      --memory-border: #0ea5e9;
      --related-topic-bg: #2e1065;
      --related-topic-text: #a78bfa;
      --image-preview-bg: #1f2937;
      --image-border: #a78bfa;
      --photo-btn-bg: #a78bfa;
      --photo-btn-hover: #9333ea;
      --key-panel-bg: #451a03;
      --key-panel-border: #f59e0b;
      --key-activated-bg: #064e3b;
      --key-activated-border: #10b981;
      --key-expired-bg: #450a0a;
      --key-expired-border: #ef4444;
      --key-deleted-bg: #111827;
      --key-deleted-border: #6b7280;
      --auth-bg: #1f2937;
      --auth-border: #374151;
      --input-bg: #374151;
      --input-border: #4b5563;
      --input-focus: #a78bfa;
      --button-bg: #a78bfa;
      --button-hover: #9333ea;
      --link-color: #a78bfa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end));
      color: var(--text-color);
      min-height: 100vh;
      padding: 1rem;
      transition: var(--transition);
    }

    header {
      margin-bottom: 1rem;
      text-align: center;
      font-size: 1.125rem;
      font-weight: 500;
    }

    /* Enhanced Authentication UI Styles */
    #auth-container {
      width: 100%;
      max-width: 400px;
      background: var(--auth-bg);
      border-radius: 1rem;
      padding: 2rem;
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      border: 1px solid var(--auth-border);
    }

    .auth-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .auth-header h2 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
    }

    .auth-header p {
      opacity: 0.7;
      font-size: 0.9rem;
    }

    .auth-tabs {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 2rem;
    }

    .auth-tab {
      flex: 1;
      padding: 1rem;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-color);
      opacity: 0.6;
      transition: var(--transition);
      border-bottom: 2px solid transparent;
    }

    .auth-tab.active {
      opacity: 1;
      border-bottom-color: var(--primary-color);
      color: var(--primary-color);
    }

    .auth-form {
      display: none;
    }

    .auth-form.active {
      display: block;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    .form-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text-color);
    }

    .form-input {
      width: 100%;
      padding: 0.875rem;
      border: 2px solid var(--input-border);
      border-radius: 0.5rem;
      font-size: 0.95rem;
      background-color: var(--input-bg);
      color: var(--text-color);
      transition: var(--transition);
    }

    .form-input:focus {
      outline: none;
      border-color: var(--input-focus);
      box-shadow: 0 0 0 3px rgba(107, 70, 193, 0.1);
    }

    .auth-button {
      width: 100%;
      padding: 1rem;
      background: var(--button-bg);
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      margin-bottom: 1rem;
    }

    .auth-button:hover:not(:disabled) {
      background: var(--button-hover);
      transform: translateY(-1px);
    }

    .auth-button:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    .auth-status {
      padding: 0.75rem;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
      text-align: center;
      display: none;
    }

    .auth-status.success {
      background: #d1fae5;
      color: #065f46;
      border: 1px solid #10b981;
    }

    .auth-status.error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #ef4444;
    }

    .auth-status.info {
      background: #dbeafe;
      color: #1e40af;
      border: 1px solid #3b82f6;
    }

    .auth-links {
      text-align: center;
    }

    .auth-link {
      color: var(--link-color);
      text-decoration: none;
      font-size: 0.875rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .auth-link:hover {
      text-decoration: underline;
    }

    .password-requirements {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 0.25rem;
    }

    .device-info {
      background: rgba(var(--primary-color), 0.1);
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 1rem;
      border: 1px solid rgba(var(--primary-color), 0.3);
    }

    .device-info-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    .device-info-item {
      display: flex;
      justify-content: space-between;
      margin: 0.25rem 0;
      font-size: 0.875rem;
    }

    .app-container {
      width: 100%;
      max-width: min(90vw, 50rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      display: none; /* Hidden until authenticated */
    }

    /* Enhanced Key System Styles */
    .key-panel {
      background: var(--key-panel-bg);
      border: 2px solid var(--key-panel-border);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-bottom: 1rem;
      backdrop-filter: var(--blur);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }

    .key-panel.activated {
      background: var(--key-activated-bg);
      border-color: var(--key-activated-border);
    }

    .key-panel.expired {
      background: var(--key-expired-bg);
      border-color: var(--key-expired-border);
      animation: expiredPulse 2s infinite;
    }

    .key-panel.deleted {
      background: var(--key-deleted-bg);
      border-color: var(--key-deleted-border);
      opacity: 0.7;
    }

    @keyframes expiredPulse {
      0%, 100% { border-color: var(--key-expired-border); }
      50% { border-color: #fca5a5; }
    }

    .key-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .key-status {
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .key-status .countdown {
      font-size: 0.875rem;
      font-weight: 500;
      margin-left: 0.5rem;
      padding: 0.25rem 0.5rem;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0.375rem;
    }

    .key-toggle-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      min-width: 80px;
    }

    .key-toggle-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    .key-details {
      display: none;
    }

    .key-details.show {
      display: block;
    }

    .key-input-group {
      display: flex;
      gap: 0.5rem;
      margin: 0.75rem 0;
    }

    .key-input {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      transition: var(--transition);
      text-transform: uppercase;
    }

    .key-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.75rem rgba(107, 70, 193, 0.4);
    }

    .key-input:disabled {
      background-color: #f3f4f6;
      color: #6b7280;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .key-submit-btn {
      background: var(--toast-success);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      white-space: nowrap;
    }

    .key-submit-btn:hover {
      background: #059669;
      transform: translateY(-0.125rem);
    }

    .key-submit-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    .user-status {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0.5rem;
      padding: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .user-status.verified {
      background: rgba(16, 185, 129, 0.2);
      color: var(--toast-success);
    }

    .user-status.unverified {
      background: rgba(239, 68, 68, 0.2);
      color: var(--toast-error);
    }

    .key-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 0.75rem;
      margin: 0.75rem 0;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
      backdrop-filter: blur(2px);
    }

    .key-info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.875rem;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 0.375rem;
    }

    .key-info-label {
      font-weight: 600;
      opacity: 0.8;
    }

    .key-info-value {
      font-weight: 500;
      text-align: right;
    }

    .key-countdown {
      font-size: 0.8125rem;
      padding: 0.375rem 0.75rem;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border-radius: 0.375rem;
      margin-top: 0.5rem;
      text-align: center;
      font-weight: 600;
      letter-spacing: 0.025em;
    }

    .key-countdown.warning {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      animation: warningPulse 1s infinite;
    }

    .key-countdown.critical {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      animation: criticalPulse 0.5s infinite;
    }

    @keyframes warningPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes criticalPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.02); }
    }

    .realtime-indicator {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      width: 8px;
      height: 8px;
      background: var(--toast-success);
      border-radius: 50%;
      animation: realtimePulse 2s infinite;
    }

    @keyframes realtimePulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .activation-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(16, 185, 129, 0.2);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .activation-animation.show {
      opacity: 1;
      pointer-events: auto;
    }

    .activation-content {
      background: var(--chat-bg);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      transform: scale(0.8);
      transition: transform 0.5s ease;
    }

    .activation-animation.show .activation-content {
      transform: scale(1);
    }

    .activation-checkmark {
      font-size: 4rem;
      color: var(--toast-success);
      margin-bottom: 1rem;
      animation: checkmarkPulse 1s ease-in-out;
    }

    @keyframes checkmarkPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .blocked-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    .blocked-message {
      background: var(--chat-bg);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      border: 2px solid var(--toast-error);
    }

    .blocked-message h3 {
      color: var(--toast-error);
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .blocked-message .pulsing-text {
      animation: textPulse 1.5s infinite;
    }

    @keyframes textPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Enhanced performance-optimized controls */
    #controls-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    #model-selector-container, #conversation-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--chat-bg);
      border-radius: 0.5rem;
      border: 1px solid var(--border-color);
    }

    .sign-out-btn {
      background: #dc2626;
      color: white;
      border: none;
      border-radius: 0.375rem;
      padding: 0.375rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .sign-out-btn:hover {
      background: #b91c1c;
    }

    #model-select, #conversation-select {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      cursor: pointer;
      transition: var(--transition);
      backdrop-filter: var(--blur);
      flex: 1;
      min-width: 120px;
    }

    #model-select:focus, #conversation-select:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.625rem rgba(107, 70, 193, 0.3);
    }

    .theme-toggle, .conversation-controls {
      display: flex;
      align-items: center;
      gap: 0.625rem;
    }

    .theme-toggle-label, .conversation-controls button {
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
    }

    .theme-toggle-switch {
      position: relative;
      width: 3.5rem;
      height: 1.75rem;
    }

    .theme-toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .theme-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border-color);
      border-radius: 1.75rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      padding: 0 0.25rem;
    }

    .theme-toggle-slider:before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='5'/%3E%3Cpath d='M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42'/%3E%3C/svg%3E");
      height: 1.5rem;
      width: 1.5rem;
      background-color: var(--chat-bg);
      border-radius: 50%;
      transition: var(--transition);
      transform: translateX(0);
    }

    .theme-toggle-switch input:checked + .theme-toggle-slider {
      background-color: var(--primary-color);
    }

    .theme-toggle-switch input:checked + .theme-toggle-slider:before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z'/%3E%3C/svg%3E");
      transform: translateX(1.75rem);
    }

    .theme-toggle-switch input:focus + .theme-toggle-slider {
      box-shadow: 0 0 0.5rem var(--primary-color);
    }

    #new-conversation-btn, #delete-conversation-btn, #clear-memory-btn {
      padding: 0.625rem 1.25rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: var(--transition);
      min-width: 80px;
    }

    #new-conversation-btn:hover, #delete-conversation-btn:hover, #clear-memory-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    #delete-conversation-btn:disabled, #clear-memory-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    #clear-memory-btn {
      background: #dc2626;
    }

    #clear-memory-btn:hover:not(:disabled) {
      background: #b91c1c;
    }

    .memory-panel {
      background: var(--memory-bg);
      border: 1px solid var(--memory-border);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-bottom: 1rem;
      max-height: 250px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg);
      backdrop-filter: var(--blur);
    }

    .memory-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--memory-border);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .topic-tag, .related-topic-tag {
      display: inline-block;
      background: var(--topic-tag-bg);
      color: var(--topic-tag-text);
      padding: 0.25rem 0.5rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      margin: 0.125rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .related-topic-tag {
      background: var(--related-topic-bg);
      color: var(--related-topic-text);
    }

    .topic-tag:hover, .related-topic-tag:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow);
    }

    .conversation-topic {
      background: var(--chat-bg);
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin: 0.5rem 0;
      backdrop-filter: var(--blur);
      cursor: pointer;
    }

    .conversation-title {
      font-weight: 600;
      color: var(--primary-color);
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
    }

    .conversation-summary {
      font-size: 0.8125rem;
      opacity: 0.8;
      line-height: 1.4;
    }

    .conversation-date {
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 0.25rem;
    }

    .sync-status {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background: var(--chat-bg);
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      box-shadow: var(--shadow);
      display: none;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      z-index: 100;
      max-width: 300px;
    }

    .sync-status.show {
      display: flex;
    }

    .sync-spinner {
      width: 1rem;
      height: 1rem;
      border: 2px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Ultra-optimized chat container */
    #chat-container {
      width: 100%;
      min-height: 20rem;
      max-height: 60vh;
      border: 1px solid var(--chat-border);
      border-radius: 0.75rem;
      background-color: var(--chat-bg);
      backdrop-filter: var(--blur);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg);
      transition: var(--transition);
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      contain: layout;
    }

    /* High-performance scrollbar */
    #chat-container::-webkit-scrollbar {
      width: 6px;
    }

    #chat-container::-webkit-scrollbar-track {
      background: var(--scrollbar-bg);
      border-radius: 3px;
    }

    #chat-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-color);
      border-radius: 3px;
    }

    #chat-container::-webkit-scrollbar-thumb:hover {
      background: var(--primary-dark);
    }

    .message {
      margin: 0.75rem 0;
      padding: 0.75rem 1.125rem;
      border-radius: 0.75rem;
      max-width: 80%;
      word-wrap: break-word;
      animation: fadeIn 0.4s ease-in;
      position: relative;
      color: var(--text-color);
      transition: transform 0.2s ease;
      overflow: hidden;
      contain: layout style paint;
      will-change: transform, opacity;
    }

    .message:hover {
      transform: scale(1.02);
    }

    .message .timestamp {
      font-size: 0.75rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-top: 0.5rem;
      text-align: right;
    }

    .user {
      background: var(--user-bg);
      color: white;
      margin-left: auto;
      text-align: right;
      box-shadow: var(--shadow);
    }

    .ai {
      background: var(--ai-bg);
      margin-right: auto;
      text-align: left;
      box-shadow: var(--shadow);
      padding-right: 1.125rem;
    }

    .message-content {
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-width: 100%;
      position: relative;
      contain: layout style;
    }

    .message-content .copy-btn-inline {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.25rem;
      padding: 0.125rem 0.375rem;
      font-size: 0.625rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease, background-color 0.2s ease;
      z-index: 10;
    }

    .message-content:hover .copy-btn-inline {
      opacity: 0.8;
    }

    .message-content .copy-btn-inline:hover {
      opacity: 1;
      background-color: var(--primary-dark);
    }

    .code-block {
      position: relative;
      background-color: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      overflow: hidden;
      max-width: 100%;
      contain: layout style paint;
    }

    .code-block-header {
      background-color: var(--border-color);
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--code-border);
    }

    .code-block pre {
      margin: 0;
      padding: 1rem;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-width: 100%;
      overflow-x: auto;
    }

    .code-block code {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.4;
    }

    .inline-code {
      background-color: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 0.25rem;
      padding: 0.125rem 0.375rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      position: relative;
      display: inline-block;
      cursor: pointer;
    }

    .inline-code .copy-btn-small {
      position: absolute;
      top: -0.5rem;
      right: -0.5rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 50%;
      width: 1.25rem;
      height: 1.25rem;
      font-size: 0.625rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .inline-code:hover .copy-btn-small {
      opacity: 1;
    }

    .copy-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s ease, background-color 0.2s ease;
    }

    .copy-btn:hover {
      opacity: 1;
      background-color: var(--primary-dark);
    }

    .copy-btn.copied {
      background-color: #48bb78;
    }

    .typing-indicator {
      background: var(--ai-bg);
      margin-right: auto;
      padding: 0.75rem 1.125rem;
      border-radius: 0.75rem;
      max-width: 80%;
      animation: fadeIn 0.4s ease-in;
      box-shadow: var(--shadow);
    }

    .typing-indicator::after {
      content: 'Analyzing...';
      animation: blink 1s infinite;
    }

    #input-container {
      width: 100%;
      display: flex;
      gap: 0.75rem;
      padding: 0.625rem;
      background: var(--chat-bg);
      border-radius: 0.75rem;
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      transition: var(--transition);
      flex-wrap: nowrap;
      align-items: center;
    }

    #user-input {
      flex-grow: 1;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      transition: var(--transition);
      min-width: 0;
    }

    #user-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.75rem rgba(107, 70, 193, 0.4);
      transform: translateY(-0.125rem);
    }

    .input-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    #photo-btn {
      position: relative;
      padding: 0.75rem;
      background: var(--photo-btn-bg);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 1.125rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
    }

    #photo-btn:hover {
      background: var(--photo-btn-hover);
      transform: translateY(-0.125rem);
    }

    #photo-btn input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    #send-btn {
      padding: 0.75rem 1.5rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.9375rem;
      font-weight: 500;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      min-width: 80px;
    }

    #send-btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.4s ease, height 0.4s ease;
    }

    #send-btn:hover::after {
      width: 12.5rem;
      height: 12.5rem;
    }

    #send-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    #send-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    /* Image Preview */
    .image-preview-container {
      position: relative;
      margin: 0.5rem 0;
      padding: 0.75rem;
      background: var(--image-preview-bg);
      border: 2px dashed var(--image-border);
      border-radius: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .image-preview-wrapper {
      position: relative;
      display: inline-block;
    }

    .image-preview {
      max-width: 150px;
      max-height: 150px;
      border-radius: 0.5rem;
      object-fit: cover;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .image-preview:hover {
      transform: scale(1.05);
    }

    .remove-image {
      position: absolute;
      top: -8px;
      right: -8px;
      background: var(--toast-error);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease;
    }

    .remove-image:hover {
      transform: scale(1.1);
    }

    .message-image {
      max-width: 300px;
      max-height: 300px;
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      cursor: pointer;
      transition: transform 0.2s ease;
      display: block;
    }

    .message-image:hover {
      transform: scale(1.02);
    }

    /* Image Modal */
    .image-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.9);
      animation: fadeIn 0.3s ease;
    }

    .image-modal-content {
      margin: auto;
      display: block;
      max-width: 90%;
      max-height: 90%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: zoomIn 0.3s ease;
    }

    .close-modal {
      position: absolute;
      top: 15px;
      right: 35px;
      color: #f1f1f1;
      font-size: 40px;
      font-weight: bold;
      transition: 0.3s;
      cursor: pointer;
    }

    .close-modal:hover,
    .close-modal:focus {
      color: #bbb;
      text-decoration: none;
    }

    footer {
      margin-top: 1rem;
      text-align: center;
      font-size: 1.125rem;
      font-weight: 500;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .footer-links {
      display: flex;
      justify-content: center;
      gap: 2rem;
    }

    .powered-by, .contact-link, .key-link {
      display: inline-block;
      background: linear-gradient(90deg, var(--gradient-colors));
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: gradientShift 5s linear infinite;
      transition: transform 0.2s ease;
      text-decoration: none;
      font-weight: 600;
    }

    .contact-link:hover, .key-link:hover {
      transform: scale(1.05);
    }

    /* Toast System */
    .toast-container {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: none;
    }

    .toast {
      background: white;
      border-radius: 0.5rem;
      padding: 1rem 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      min-width: 300px;
      max-width: 400px;
      transform: translateX(100%);
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: auto;
      border-left: 4px solid;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.success {
      border-left-color: var(--toast-success);
      background: #f0fdf4;
      color: #166534;
    }

    .toast.error {
      border-left-color: var(--toast-error);
      background: #fef2f2;
      color: #991b1b;
    }

    .toast.warning {
      border-left-color: var(--toast-warning);
      background: #fefdf8;
      color: #92400e;
    }

    .toast.info {
      border-left-color: var(--toast-info);
      background: #eff6ff;
      color: #1e40af;
    }

    .toast-icon {
      font-size: 1.25rem;
      flex-shrink: 0;
    }

    .toast-content {
      flex: 1;
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .toast-message {
      font-size: 0.875rem;
      opacity: 0.8;
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 1.125rem;
      cursor: pointer;
      padding: 0;
      width: 1.5rem;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    .toast-close:hover {
      opacity: 1;
    }

    .connection-status {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      background: var(--chat-bg);
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      z-index: 100;
    }

    .connection-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--toast-error);
    }

    .connection-indicator.connected {
      background: var(--toast-success);
    }

    @keyframes gradientShift {
      0% { background-position: 200% 0; }
      100% { background-position: 0 0; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(0.625rem); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes zoomIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes blink {
      50% { opacity: 0.5; }
    }

    @media (max-width: 600px) {
      body {
        padding: 0.5rem;
      }

      #auth-container {
        max-width: 95vw;
        padding: 1.5rem;
      }

      .app-container {
        max-width: 95vw;
      }

      #model-selector-container, #conversation-controls {
        flex-direction: column;
        align-items: stretch;
      }

      #model-select, #conversation-select, #new-conversation-btn, #delete-conversation-btn, #clear-memory-btn {
        width: 100%;
      }

      #chat-container {
        min-height: 15rem;
        max-height: 50vh;
        padding: 0.75rem;
      }

      .message {
        max-width: 90%;
        padding: 0.625rem 0.875rem;
      }

      #input-container {
        padding: 0.5rem;
        gap: 0.5rem;
      }

      #user-input {
        font-size: 0.875rem;
        padding: 0.625rem;
      }

      #send-btn {
        font-size: 0.875rem;
        padding: 0.625rem 1rem;
        min-width: 70px;
      }

      #photo-btn {
        width: 44px;
        height: 44px;
        font-size: 1rem;
      }

      .image-preview {
        max-width: 100px;
        max-height: 100px;
      }

      .message-image {
        max-width: 200px;
        max-height: 200px;
      }

      header, footer {
        font-size: 0.875rem;
      }

      .footer-links {
        flex-direction: column;
        gap: 0.5rem;
      }

      .memory-panel {
        max-height: 200px;
        padding: 0.75rem;
      }

      .toast-container {
        top: 0.5rem;
        right: 0.5rem;
        left: 0.5rem;
      }

      .toast {
        min-width: auto;
        max-width: none;
      }

      .typing-indicator::after {
        font-size: 0.875rem;
      }

      .connection-status {
        bottom: 0.5rem;
        left: 0.5rem;
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
      }

      .key-input-group {
        flex-direction: column;
        gap: 0.5rem;
      }

      .key-submit-btn {
        padding: 0.75rem;
      }

      .key-info {
        grid-template-columns: 1fr;
      }

      .auth-tabs {
        margin-bottom: 1.5rem;
      }

      .auth-tab {
        padding: 0.75rem;
        font-size: 0.875rem;
      }

      .user-info {
        flex-direction: column;
        gap: 0.25rem;
        text-align: center;
      }
    }

    @media (max-width: 400px) {
      #input-container {
        flex-wrap: wrap;
      }

      .input-actions {
        width: 100%;
        justify-content: space-between;
      }

      #user-input {
        width: 100%;
      }

      #send-btn {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div class="toast-container" id="toast-container"></div>

  <!-- Authentication UI -->
  <div id="auth-container">
    <div class="auth-header">
      <h2>ðŸš€ AI Chatbot Login</h2>
      <p>Secure access with email/password authentication</p>
    </div>

    <div class="auth-tabs">
      <button class="auth-tab active" id="signin-tab">Sign In</button>
      <button class="auth-tab" id="signup-tab">Sign Up</button>
    </div>

    <div id="auth-status" class="auth-status"></div>

    <!-- Sign In Form -->
    <form id="signin-form" class="auth-form active">
      <div class="form-group">
        <label for="signin-email" class="form-label">Email Address</label>
        <input type="email" id="signin-email" class="form-input" placeholder="Enter your email" required>
      </div>
      
      <div class="form-group">
        <label for="signin-password" class="form-label">Password</label>
        <input type="password" id="signin-password" class="form-input" placeholder="Enter your password" required>
      </div>

      <button type="submit" id="signin-btn" class="auth-button">Sign In</button>

      <div class="auth-links">
        <a href="#" class="auth-link" id="forgot-password-link">Forgot your password?</a>
      </div>
    </form>

    <!-- Sign Up Form -->
    <form id="signup-form" class="auth-form">
      <div class="form-group">
        <label for="signup-name" class="form-label">Display Name</label>
        <input type="text" id="signup-name" class="form-input" placeholder="Enter your name" required>
      </div>

      <div class="form-group">
        <label for="signup-email" class="form-label">Email Address</label>
        <input type="email" id="signup-email" class="form-input" placeholder="Enter your email" required>
      </div>
      
      <div class="form-group">
        <label for="signup-password" class="form-label">Password</label>
        <input type="password" id="signup-password" class="form-input" placeholder="Create password" required>
        <div class="password-requirements">Must be at least 6 characters long</div>
      </div>

      <div class="form-group">
        <label for="signup-confirm-password" class="form-label">Confirm Password</label>
        <input type="password" id="signup-confirm-password" class="form-input" placeholder="Confirm password" required>
      </div>

      <button type="submit" id="signup-btn" class="auth-button">Create Account</button>

      <div class="auth-links">
        <span style="font-size: 0.75rem; opacity: 0.7;">By signing up, you agree to one device per account policy</span>
      </div>
    </form>

    <div class="device-info">
      <div class="device-info-title">ðŸ” Device Security</div>
      <div class="device-info-item">
        <span>Security Policy:</span>
        <span>One device per account</span>
      </div>
      <div class="device-info-item">
        <span>Device ID:</span>
        <span id="device-id-display">Generating...</span>
      </div>
      <div class="device-info-item">
        <span>Email Verification:</span>
        <span>Required for activation</span>
      </div>
    </div>
  </div>

  <!-- Main Application UI (Hidden until authenticated) -->
  <div class="app-container" id="app-container">
    <!-- Activation Animation -->
    <div class="activation-animation" id="activation-animation">
      <div class="activation-content">
        <div class="activation-checkmark">âœ“</div>
        <h3>Key Activated Successfully!</h3>
        <p>User authenticated for AI access...</p>
      </div>
    </div>

    <div class="sync-status" id="sync-status">
      <div class="sync-spinner"></div>
      <span id="sync-message">Connecting to GoFile cloud...</span>
    </div>

    <div class="connection-status" id="connection-status">
      <div class="connection-indicator" id="connection-indicator"></div>
      <span id="connection-text">Connecting...</span>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="image-modal">
      <span class="close-modal" onclick="closeImageModal()">&times;</span>
      <img class="image-modal-content" id="modalImage">
    </div>

    <header>
      <span class="powered-by">AI CHATBOT WITH PHOTO ANALYSIS & ADVANCED MEMORY - POWERED BY BARNI</span>
    </header>

    <!-- User Info Bar -->
    <div class="user-info" id="user-info">
      <span id="user-display-name">Loading user...</span>
      <button class="sign-out-btn" id="sign-out-btn">Sign Out</button>
    </div>

    <!-- Enhanced UID-Based Key Activation Panel -->
    <div class="key-panel" id="key-panel">
      <div class="realtime-indicator" id="realtime-indicator"></div>
      <div class="key-header">
        <div class="key-status" id="key-status">
          ðŸ” Key Status: Checking authentication...
          <span class="countdown" id="key-countdown" style="display: none;"></span>
        </div>
        <button class="key-toggle-btn" id="key-toggle-btn" onclick="toggleKeyPanel()">
          Activate
        </button>
      </div>
      
      <div class="user-status" id="user-status">
        <span>ðŸ” Validating account...</span>
      </div>
      
      <div class="key-details" id="key-details">
        <div class="key-input-group">
          <input type="text" class="key-input" id="key-input" placeholder="Enter your activation key..." maxlength="20">
          <button class="key-submit-btn" id="key-submit-btn" onclick="activateKey()">
            Activate
          </button>
        </div>
        <div id="key-info" class="key-info"></div>
        <div id="key-countdown-display" class="key-countdown" style="display: none;"></div>
      </div>
    </div>

    <div class="memory-panel" id="memory-panel" style="display: none;">
      <div class="memory-title">
        ðŸ§  Advanced Memory Bank (GoFile Cloud)
        <button id="clear-memory-btn" style="margin-left: auto; padding: 0.25rem 0.5rem; font-size: 0.75rem;">Clear Memory</button>
      </div>
      <div id="memory-content"></div>
    </div>

    <div id="controls-container">
      <div id="model-selector-container">
        <label for="model-select" class="theme-toggle-label">Choose AI Model:</label>
        <select id="model-select" aria-label="Select AI model"></select>
        <div class="theme-toggle">
          <label for="theme-toggle" class="theme-toggle-label">Toggle Theme</label>
          <div class="theme-toggle-switch">
            <input type="checkbox" id="theme-toggle" aria-label="Toggle between light and dark theme">
            <span class="theme-toggle-slider"></span>
          </div>
        </div>
      </div>
      <div id="conversation-controls">
        <label for="conversation-select" class="theme-toggle-label">Conversation:</label>
        <select id="conversation-select" aria-label="Select conversation"></select>
        <div class="conversation-controls">
          <button id="new-conversation-btn" aria-label="Start new conversation">New</button>
          <button id="delete-conversation-btn" aria-label="Delete current conversation">Delete</button>
        </div>
      </div>
    </div>

    <!-- Image Preview Container -->
    <div id="image-preview-container" class="image-preview-container" style="display: none;">
      <div id="image-previews"></div>
    </div>

    <div id="chat-container"></div>

    <div id="input-container">
      <input type="text" id="user-input" placeholder="Type your message..." autocomplete="off" aria-label="Type your message">
      <div class="input-actions">
        <button id="photo-btn" aria-label="Attach photo">
          ðŸ“·
          <input type="file" id="file-input" accept="image/*" multiple>
        </button>
        <button id="send-btn" aria-label="Send message">Send</button>
      </div>
    </div>
  </div>

  <footer>
    <div class="footer-links">
      <a href="mailto:barnigonzales43329@gmail.com" class="contact-link" aria-label="Contact via email">CONTACT</a>
      <a href="#" class="key-link" id="key-link" onclick="toggleKeyPanel()">KEY</a>
    </div>
  </footer>

  <script>
    // Enhanced Firebase readiness detection with performance optimization
    function waitForFirebase() {
      return new Promise((resolve) => {
        if (window.firebaseReady && window.authManager) {
          resolve();
        } else {
          const handler = () => {
            if (window.firebaseReady && window.authManager) {
              window.removeEventListener('firebaseReady', handler);
              resolve();
            }
          };
          window.addEventListener('firebaseReady', handler);
          
          // Fail-safe timeout
          setTimeout(() => {
            window.removeEventListener('firebaseReady', handler);
            resolve();
          }, 10000);
        }
      });
    }

    async function initializeApp() {
      // Wait for Firebase with enhanced stability
      await waitForFirebase();
      
      // Additional stabilization period for auth
      await new Promise(resolve => setTimeout(resolve, 500));

      // Enhanced UID-Based Key System for Authenticated Users
      class AuthenticatedKeySystem {
        constructor() {
          this.isActivated = false;
          this.isBlocked = false;
          this.keyData = null;
          this.userUID = null;
          this.userEmail = null;
          this.baseUrl = 'https://barnigonz.github.io/Aib4n1x/';
          this.realtimeListener = null;
          this.countdownInterval = null;
          this.blockedOverlay = null;
          this.authChecked = false;
          this.initializationComplete = false;
          this.systemReady = false;
          this.retryAttempts = 0;
          this.maxRetryAttempts = 3;
          this.retryDelay = 1000;
          this.performanceMonitor = new Map();
          
          // Enhanced storage keys with UID binding
          this.storageKeys = {
            activation: 'ai_chatbot_uid_key_activation_v7',
            keyData: 'ai_chatbot_uid_key_data_v7',
            keyId: 'ai_chatbot_uid_key_id_v7',
            activationTime: 'ai_chatbot_uid_activation_time_v7',
            userBinding: 'ai_chatbot_uid_user_binding_v7',
            lastValidation: 'ai_chatbot_uid_last_validation_v7'
          };
          
          // Performance-optimized initialization
          this.initWithPerformanceTracking();
        }

        async initWithPerformanceTracking() {
          const startTime = performance.now();
          
          try {
            await this.waitForAuthenticatedUser();
            this.updateUserStatus();
            this.authChecked = true;
            
            // Check for perpetual activation first
            const hasPersistentActivation = await this.checkUIDBindingActivation();
            
            // Only check URL if no persistent activation exists
            if (!hasPersistentActivation) {
              await this.checkUrlKeyOptimized();
            }
            
            this.updateUI();
            this.startOptimizedCountdown();
            this.initializationComplete = true;
            this.systemReady = true;
            
            const endTime = performance.now();
            this.performanceMonitor.set('initialization', endTime - startTime);
            console.log(`Key system initialized in ${(endTime - startTime).toFixed(2)}ms`);
            
          } catch (error) {
            console.error('Authenticated key system initialization error:', error);
            this.systemReady = true;
            this.initializationComplete = true;
          }
        }

        async waitForAuthenticatedUser() {
          return new Promise((resolve) => {
            const checkAuth = () => {
              const currentUser = window.authManager?.getCurrentUser();
              
              if (currentUser && window.authManager?.isUserAuthenticated()) {
                this.userUID = currentUser.uid;
                this.userEmail = currentUser.email;
                this.persistUserBinding();
                console.log('Authenticated user acquired:', this.userEmail);
                resolve();
              } else if (this.retryAttempts < this.maxRetryAttempts) {
                this.retryAttempts++;
                setTimeout(checkAuth, this.retryDelay * this.retryAttempts);
              } else {
                // Try to restore from persistent storage
                const storedBinding = this.getStoredUserBinding();
                if (storedBinding) {
                  this.userUID = storedBinding.uid;
                  this.userEmail = storedBinding.email;
                  console.log('Restored user binding from storage:', this.userEmail);
                }
                resolve();
              }
            };
            
            // Listen for auth changes with immediate resolution
            if (window.authManager) {
              window.addEventListener('userAuthenticated', (event) => {
                if (event.detail?.user) {
                  this.userUID = event.detail.user.uid;
                  this.userEmail = event.detail.user.email;
                  this.persistUserBinding();
                  resolve();
                }
              }, { once: true });
            }
            
            checkAuth();
          });
        }

        persistUserBinding() {
          try {
            const bindingData = {
              uid: this.userUID,
              email: this.userEmail,
              deviceInfo: window.authManager?.getDeviceInfo(),
              timestamp: Date.now(),
              version: '7.0'
            };
            localStorage.setItem(this.storageKeys.userBinding, JSON.stringify(bindingData));
            sessionStorage.setItem(this.storageKeys.userBinding, JSON.stringify(bindingData));
          } catch (e) {
            console.warn('Failed to persist user binding:', e);
          }
        }

        getStoredUserBinding() {
          const sources = [
            () => sessionStorage.getItem(this.storageKeys.userBinding),
            () => localStorage.getItem(this.storageKeys.userBinding)
          ];
          
          for (const getSource of sources) {
            try {
              const data = getSource();
              if (data) {
                const parsed = JSON.parse(data);
                if (parsed.uid && parsed.email && parsed.version === '7.0') {
                  return parsed;
                }
              }
            } catch (e) {
              continue;
            }
          }
          return null;
        }

        updateUserStatus() {
          const userStatus = document.getElementById('user-status');
          if (this.userUID && this.userEmail) {
            const shortUID = this.userUID.slice(0, 8) + '...';
            userStatus.className = 'user-status verified';
            userStatus.innerHTML = `<span>âœ… Authenticated User: ${this.userEmail} (${shortUID})</span>`;
          } else {
            userStatus.className = 'user-status unverified';
            userStatus.innerHTML = `<span>âŒ User authentication pending...</span>`;
          }
        }

        // UID-based storage with user binding
        setUIDBasedStorage(key, value) {
          if (!this.userUID) {
            console.warn('No UID available for storage binding');
            return;
          }

          const data = {
            value: value,
            timestamp: Date.now(),
            uid: this.userUID,
            email: this.userEmail,
            version: '7.0',
            uidBound: true
          };

          const serialized = JSON.stringify(data);
          const uidKey = `${key}_${this.userUID}`;

          try {
            // Triple redundancy storage with UID binding
            localStorage.setItem(uidKey, serialized);
            localStorage.setItem(uidKey + '_backup', serialized);
            localStorage.setItem(uidKey + '_emergency', serialized);
            sessionStorage.setItem(uidKey, serialized);
            sessionStorage.setItem(uidKey + '_session_backup', serialized);
          } catch (e) {
            console.warn('UID-based storage failed, using memory fallback:', e);
            this.memoryFallback = this.memoryFallback || new Map();
            this.memoryFallback.set(uidKey, data);
          }
        }

        getUIDBasedStorage(key) {
          if (!this.userUID) {
            return null;
          }

          const uidKey = `${key}_${this.userUID}`;
          const sources = [
            () => sessionStorage.getItem(uidKey),
            () => sessionStorage.getItem(uidKey + '_session_backup'),
            () => localStorage.getItem(uidKey),
            () => localStorage.getItem(uidKey + '_backup'),
            () => localStorage.getItem(uidKey + '_emergency'),
            () => this.memoryFallback?.get(uidKey)
          ];

          for (const getSource of sources) {
            try {
              const item = getSource();
              if (item) {
                let data;
                if (typeof item === 'string') {
                  data = JSON.parse(item);
                } else {
                  data = item;
                }

                if (data?.uid === this.userUID &&
                    data?.uidBound &&
                    data?.version === '7.0' &&
                    data?.value !== undefined) {
                  return data.value;
                }
              }
            } catch (e) {
              continue;
            }
          }
          return null;
        }

        removeUIDBasedStorage(key) {
          if (!this.userUID) return;

          const uidKey = `${key}_${this.userUID}`;
          const keys = [uidKey, uidKey + '_backup', uidKey + '_emergency', uidKey + '_session_backup'];
          keys.forEach(k => {
            try {
              localStorage.removeItem(k);
              sessionStorage.removeItem(k);
            } catch (e) {
              console.warn('Failed to remove UID-based storage key:', k, e);
            }
          });

          if (this.memoryFallback) {
            this.memoryFallback.delete(uidKey);
          }
        }

        async checkUIDBindingActivation() {
          try {
            const persistedActivation = this.getUIDBasedStorage(this.storageKeys.activation);
            const persistedKeyData = this.getUIDBasedStorage(this.storageKeys.keyData);
            const persistedKeyId = this.getUIDBasedStorage(this.storageKeys.keyId);

            console.log('Checking UID-bound activation:', {
              activation: persistedActivation,
              hasKeyData: !!persistedKeyData,
              keyId: persistedKeyId,
              uid: this.userUID,
              email: this.userEmail
            });

            if (persistedActivation && persistedKeyData && persistedKeyId && this.userUID) {
              console.log('Found UID-bound activation for user:', this.userEmail);
              
              try {
                // Validate the UID-bound key
                await this.validateUIDBasedKey(persistedKeyId, true);
                console.log('Successfully restored UID-bound activation');
                this.queueToast('success', 'User Authorized', `Welcome back ${this.userEmail}! Your activation is active.`);
                return true;
              } catch (error) {
                console.log('UID-bound key validation failed:', error.message);
                
                // Handle deletion/expiration but maintain UID binding option
                if (error.message.includes('deleted')) {
                  this.blockUser('Key Deleted', 'Your activation key has been permanently deleted by admin.');
                } else if (error.message.includes('expired')) {
                  this.blockUser('Key Expired', error.message);
                } else {
                  // For other errors, clear and allow re-activation
                  this.clearUIDBasedActivation();
                }
                return false;
              }
            }
          } catch (error) {
            console.error('Error checking UID-bound activation:', error);
          }
          return false;
        }

        clearUIDBasedActivation() {
          console.log('Clearing UID-bound activation for re-activation');
          this.removeUIDBasedStorage(this.storageKeys.activation);
          this.removeUIDBasedStorage(this.storageKeys.keyData);
          this.removeUIDBasedStorage(this.storageKeys.keyId);
          this.removeUIDBasedStorage(this.storageKeys.activationTime);
          this.removeUIDBasedStorage(this.storageKeys.lastValidation);
          this.isActivated = false;
          this.keyData = null;
        }

        async checkUrlKeyOptimized() {
          const path = window.location.pathname;
          const pathParts = path.split('/').filter(p => p);
          
          let potentialKey = null;
          
          if (pathParts.length >= 2 && pathParts[pathParts.length - 2] === 'Aib4n1x') {
            potentialKey = pathParts[pathParts.length - 1];
          } else if (pathParts.length === 1) {
            potentialKey = pathParts[0];
          }
          
          if (potentialKey &&
              !potentialKey.includes('.') &&
              potentialKey.length >= 6 &&
              potentialKey.length <= 16 &&
              /^[A-Z0-9]+$/i.test(potentialKey)) {
            
            console.log('Found potential URL key:', potentialKey);
            try {
              await this.validateUIDBasedKey(potentialKey.toUpperCase());
            } catch (error) {
              console.error('URL key validation failed:', error);
              if (this.systemReady && (error.message.includes('does not exist') ||
                                      error.message.includes('expired') ||
                                      error.message.includes('used'))) {
                this.queueToast('error', 'Invalid URL Key', 'The key in the URL is invalid or expired.');
              }
            }
          }
        }

        parseKeyDate(dateValue) {
          if (!dateValue) return null;
          
          if (dateValue && typeof dateValue.toDate === 'function') {
            return dateValue.toDate();
          }
          
          if (typeof dateValue === 'string') {
            return new Date(dateValue);
          }
          
          if (dateValue instanceof Date) {
            return dateValue;
          }
          
          if (dateValue && typeof dateValue === 'object' && dateValue.seconds) {
            return new Date(dateValue.seconds * 1000);
          }
          
          return null;
        }

        startUltraFastRealtimeMonitoring(keyId) {
          if (this.realtimeListener) {
            this.realtimeListener();
          }
          
          if (!keyId || !window.firebaseDB || !window.firebaseModules) {
            return;
          }
          
          const { doc, onSnapshot } = window.firebaseModules;
          
          console.log('Starting ultra-fast realtime monitoring for key:', keyId);
          
          this.realtimeListener = onSnapshot(
            doc(window.firebaseDB, 'activation_keys', keyId),
            (docSnapshot) => {
              const startTime = performance.now();
              
              if (!docSnapshot.exists()) {
                console.log('Key deleted - immediate response');
                this.handleKeyDeletedInstantly();
                return;
              }
              
              const newKeyData = docSnapshot.data();
              console.log('Key updated in realtime:', newKeyData);
              
              this.checkKeyStatusChangeInstantly(newKeyData);
              
              const endTime = performance.now();
              this.performanceMonitor.set('realtimeUpdate', endTime - startTime);
            },
            (error) => {
              console.error('Realtime monitoring error:', error);
              this.queueToast('warning', 'Monitoring Interrupted', 'Real-time key monitoring temporarily interrupted. Attempting to restore...');
              
              // Auto-retry realtime connection
              setTimeout(() => {
                this.startUltraFastRealtimeMonitoring(keyId);
              }, 2000);
            }
          );
        }

        checkKeyStatusChangeInstantly(newKeyData) {
          const wasActivated = this.isActivated;
          const oldExpiryDate = this.keyData?.expiresAt ? this.parseKeyDate(this.keyData.expiresAt) : null;
          const newExpiryDate = newKeyData.expiresAt ? this.parseKeyDate(newKeyData.expiresAt) : null;
          
          // Update key data with zero latency
          this.keyData = { ...newKeyData, id: this.keyData?.id };
          
          // Update UID-based persistent data instantly to maintain activation
          if (this.isActivated) {
            this.setUIDBasedStorage(this.storageKeys.keyData, JSON.stringify(this.keyData));
          }
          
          // Zero-lag expiry check
          if (newExpiryDate && new Date() > newExpiryDate) {
            if (wasActivated) {
              this.handleKeyExpiredInstantly();
            }
            return;
          }
          
          // Instant notification for key extension
          if (oldExpiryDate && newExpiryDate && newExpiryDate > oldExpiryDate) {
            this.queueToast('success', 'Key Extended', 'Your activation key has been extended!');
          }
          
          this.updateUI();
        }

        handleKeyDeletedInstantly() {
          console.log('Key deleted by admin - instant blocking');
          this.isActivated = false;
          this.keyData = null;
          this.clearUIDBasedActivation();
          
          this.blockUser('Key Deleted', 'This key has been deleted by admin');
          this.updateUI();
          
          this.queueToast('error', 'Key Deleted', 'Your activation key has been deleted by admin.');
        }

        handleKeyExpiredInstantly() {
          console.log('Key expired - instant blocking');
          this.isActivated = false;
          this.clearUIDBasedActivation();
          
          this.blockUser('Key Expired', 'Your activation key has expired. Please contact support to renew.');
          this.updateUI();
          
          this.queueToast('error', 'Key Expired', 'Your activation key has expired.');
        }

        blockUser(title, message) {
          this.isBlocked = true;
          this.showBlockedOverlay(title, message);
          this.blockAIFunctionality();
        }

        showBlockedOverlay(title, message) {
          if (this.blockedOverlay) {
            this.blockedOverlay.remove();
          }
          
          this.blockedOverlay = document.createElement('div');
          this.blockedOverlay.className = 'blocked-overlay';
          this.blockedOverlay.innerHTML = `
            <div class="blocked-message">
              <h3>${title}</h3>
              <p class="pulsing-text">${message}</p>
              <p style="margin-top: 1rem; font-size: 0.875rem; opacity: 0.8;">
                All AI functionality has been disabled.
              </p>
            </div>
          `;
          
          document.body.appendChild(this.blockedOverlay);
        }

        hideBlockedOverlay() {
          if (this.blockedOverlay) {
            this.blockedOverlay.remove();
            this.blockedOverlay = null;
          }
          this.isBlocked = false;
        }

        startOptimizedCountdown() {
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
          
          // Use optimized interval timing
          this.countdownInterval = setInterval(() => {
            this.updateCountdownOptimized();
          }, 1000);
        }

        updateCountdownOptimized() {
          if (!this.isActivated || !this.keyData?.expiresAt) {
            this.hideCountdown();
            return;
          }
          
          const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
          if (!expiryDate) {
            this.hideCountdown();
            return;
          }
          
          const now = new Date();
          const timeLeft = expiryDate - now;
          
          if (timeLeft <= 0) {
            this.handleKeyExpiredInstantly();
            return;
          }
          
          const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
          const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
          
          let countdownText = '';
          let countdownClass = '';
          
          if (days > 0) {
            countdownText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
          } else if (hours > 0) {
            countdownText = `${hours}h ${minutes}m ${seconds}s`;
            if (hours < 24) countdownClass = 'warning';
          } else {
            countdownText = `${minutes}m ${seconds}s`;
            countdownClass = minutes < 30 ? 'critical' : 'warning';
          }
          
          this.showCountdown(countdownText, countdownClass);
        }

        showCountdown(text, className = '') {
          const countdownDisplay = document.getElementById('key-countdown-display');
          const countdownInline = document.getElementById('key-countdown');
          
          if (countdownDisplay) {
            countdownDisplay.textContent = `Expires in: ${text}`;
            countdownDisplay.className = `key-countdown ${className}`;
            countdownDisplay.style.display = 'block';
          }
          
          if (countdownInline) {
            countdownInline.textContent = text;
            countdownInline.style.display = 'inline-block';
          }
        }

        hideCountdown() {
          const countdownDisplay = document.getElementById('key-countdown-display');
          const countdownInline = document.getElementById('key-countdown');
          
          if (countdownDisplay) {
            countdownDisplay.style.display = 'none';
          }
          
          if (countdownInline) {
            countdownInline.style.display = 'none';
          }
        }

        async validateUIDBasedKey(key, isRestore = false) {
          const startTime = performance.now();
          
          if (!window.firebaseDB || !window.firebaseModules) {
            throw new Error('Firebase not initialized');
          }
          
          // Use authenticated UID directly
          const currentUser = window.authManager?.getCurrentUser();
          if (!currentUser || !this.userUID) {
            throw new Error('Authenticated user required for key activation');
          }
          
          const { doc, getDoc, updateDoc, serverTimestamp } = window.firebaseModules;
          
          try {
            console.log('Validating key with UID-based binding:', key);
            const keyDoc = await getDoc(doc(window.firebaseDB, 'activation_keys', key));
            
            if (!keyDoc.exists()) {
              throw new Error('Key does not exist');
            }
            
            const keyData = keyDoc.data();
            console.log('Key data retrieved for UID binding:', keyData);
            
            // Instant expiry validation
            if (keyData.expiresAt) {
              const expiryDate = this.parseKeyDate(keyData.expiresAt);
              if (expiryDate && new Date() > expiryDate) {
                throw new Error(`Key has expired on ${expiryDate.toLocaleString()}`);
              }
            }
            
            // One-time key validation
            if (keyData.isOneTime && keyData.isUsed) {
              throw new Error('Key has already been used');
            }
            
            // UID binding validation - strict enforcement
            if (keyData.userUID && keyData.userUID !== this.userUID) {
              throw new Error('Key is bound to a different user account');
            }

            // Email verification for additional security
            if (keyData.userEmail && keyData.userEmail !== this.userEmail) {
              throw new Error('Key is bound to a different email address');
            }
            
            // Optimized database update (only for new activations)
            if (!isRestore) {
              const updateData = {
                lastAccessed: serverTimestamp(),
                accessCount: (keyData.accessCount || 0) + 1
              };
              
              if (!keyData.userUID) {
                updateData.userUID = this.userUID;
                updateData.userEmail = this.userEmail;
                updateData.activatedAt = serverTimestamp();
                updateData.activatedFrom = window.location.hostname;
                updateData.deviceInfo = window.authManager?.getDeviceInfo();
              }
              
              if (keyData.isOneTime && !keyData.isUsed) {
                updateData.isUsed = true;
                updateData.usedAt = serverTimestamp();
              }
              
              try {
                await updateDoc(doc(window.firebaseDB, 'activation_keys', key), updateData);
              } catch (updateError) {
                console.warn('Non-critical update failed:', updateError);
              }
            }
            
            // Activate with UID-based binding
            this.isActivated = true;
            this.keyData = { ...keyData, id: key };
            
            // Store with UID-based binding for indefinite activation
            const activationTime = Date.now();
            this.setUIDBasedStorage(this.storageKeys.activation, key);
            this.setUIDBasedStorage(this.storageKeys.keyData, JSON.stringify(this.keyData));
            this.setUIDBasedStorage(this.storageKeys.keyId, key);
            this.setUIDBasedStorage(this.storageKeys.activationTime, activationTime);
            this.setUIDBasedStorage(this.storageKeys.lastValidation, Date.now());
            
            // Remove any blocking
            this.hideBlockedOverlay();
            
            // Show activation animation for new activations
            if (!isRestore) {
              this.showActivationAnimation();
              
              // Intelligent URL management
              setTimeout(() => {
                const newUrl = `${this.baseUrl}${key}`;
                const currentUrl = window.location.href;
                
                if (!currentUrl.includes(key)) {
                  window.history.replaceState({}, '', `/${key}`);
                }
              }, 3000);
            }
            
            // Start ultra-fast realtime monitoring
            this.startUltraFastRealtimeMonitoring(key);
            
            const expiryDate = this.parseKeyDate(keyData.expiresAt);
            const expiryText = expiryDate ? ' until ' + expiryDate.toLocaleDateString() : '';
            
            if (!isRestore) {
              this.queueToast('success', 'User Activated!',
                `Your account ${this.userEmail} is now authorized for AI access${expiryText}. This activation is permanently bound to your UID and device.`);
            }
            
            const endTime = performance.now();
            this.performanceMonitor.set('keyValidation', endTime - startTime);
            console.log(`Key validation completed in ${(endTime - startTime).toFixed(2)}ms`);
            
          } catch (firestoreError) {
            console.error('Firestore validation error:', firestoreError);
            
            if (firestoreError.code === 'permission-denied') {
              throw new Error('Permission denied. Please ensure you have a valid key.');
            } else if (firestoreError.code === 'unavailable') {
              throw new Error('Database temporarily unavailable. Please try again.');
            } else {
              throw new Error(firestoreError.message || 'Failed to validate key');
            }
          }
        }

        showActivationAnimation() {
          const animation = document.getElementById('activation-animation');
          animation.classList.add('show');
          
          setTimeout(() => {
            animation.classList.remove('show');
          }, 3000);
        }

        updateUI() {
          const keyPanel = document.getElementById('key-panel');
          const keyStatus = document.getElementById('key-status');
          const keyToggleBtn = document.getElementById('key-toggle-btn');
          const keyDetails = document.getElementById('key-details');
          const keyInfo = document.getElementById('key-info');
          const keyInput = document.getElementById('key-input');
          const keySubmitBtn = document.getElementById('key-submit-btn');
          
          if (this.isActivated && this.keyData) {
            keyPanel.classList.remove('expired', 'deleted');
            keyPanel.classList.add('activated');
            
            let statusText = 'âœ… User Activated (UID-Bound)';
            let statusClass = 'activated';
            
            if (this.keyData.expiresAt) {
              const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
              const now = new Date();
              
              if (expiryDate && now > expiryDate) {
                statusText = 'âŒ Expired';
                statusClass = 'expired';
                this.isActivated = false;
              } else if (expiryDate) {
                const timeLeft = expiryDate - now;
                const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                
                if (days > 0) {
                  statusText = `âœ… Active (${days} days left)`;
                } else if (hours > 0) {
                  statusText = `âš ï¸ Active (${hours} hours left)`;
                } else {
                  statusText = `â° Expiring Soon`;
                }
              }
            }
            
            keyStatus.innerHTML = `ðŸ” Key Status: ${statusText} <span class="countdown" id="key-countdown" style="display: none;"></span>`;
            keyPanel.className = `key-panel ${statusClass}`;
            keyToggleBtn.textContent = 'User Info';
            
            if (keyInput) {
              keyInput.disabled = true;
              keyInput.placeholder = 'User Activated Successfully (UID-Bound)';
            }
            if (keySubmitBtn) {
              keySubmitBtn.disabled = true;
              keySubmitBtn.textContent = 'Activated';
            }
            
            if (keyDetails.classList.contains('show')) {
              const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
              const createdDate = this.parseKeyDate(this.keyData.createdAt);
              const activationTime = this.getUIDBasedStorage(this.storageKeys.activationTime);
              const activatedDate = activationTime ? new Date(activationTime) : null;
              
              keyInfo.innerHTML = `
                <div class="key-info-item">
                  <span class="key-info-label">Key ID:</span>
                  <span class="key-info-value">${this.keyData.id}</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">User Email:</span>
                  <span class="key-info-value">${this.userEmail}</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">User UID:</span>
                  <span class="key-info-value">${this.userUID?.slice(0, 8)}...</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Type:</span>
                  <span class="key-info-value">${this.keyData.isOneTime ? 'One-time use' : (this.keyData.expiresAt ? 'Expiring' : 'Permanent')}</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Binding:</span>
                  <span class="key-info-value">UID-BASED (Ultra-Secure)</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Device Policy:</span>
                  <span class="key-info-value">One Device Per Account</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Monitoring:</span>
                  <span class="key-info-value">Real-time (Zero-lag)</span>
                </div>
                ${this.keyData.description ? `
                <div class="key-info-item">
                  <span class="key-info-label">Description:</span>
                  <span class="key-info-value">${this.keyData.description}</span>
                </div>` : ''}
                ${createdDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Created:</span>
                  <span class="key-info-value">${createdDate.toLocaleDateString()} ${createdDate.toLocaleTimeString()}</span>
                </div>` : ''}
                ${activatedDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Activated:</span>
                  <span class="key-info-value">${activatedDate.toLocaleDateString()} ${activatedDate.toLocaleTimeString()}</span>
                </div>` : ''}
                ${expiryDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Expires:</span>
                  <span class="key-info-value">${expiryDate.toLocaleDateString()} ${expiryDate.toLocaleTimeString()}</span>
                </div>` : ''}
                <div class="key-info-item">
                  <span class="key-info-label">Access Count:</span>
                  <span class="key-info-value">${this.keyData.accessCount || 0}</span>
                </div>
              `;
            }
          } else {
            keyPanel.classList.remove('activated');
            
            if (keyInput) {
              keyInput.disabled = false;
              keyInput.placeholder = 'Enter your activation key...';
            }
            if (keySubmitBtn) {
              keySubmitBtn.disabled = false;
              keySubmitBtn.textContent = 'Activate';
            }
            
            const storedKeyData = this.getUIDBasedStorage(this.storageKeys.keyData);
            if (storedKeyData) {
              try {
                const parsed = JSON.parse(storedKeyData);
                if (parsed.expiresAt && new Date() > new Date(parsed.expiresAt)) {
                  keyPanel.classList.add('expired');
                  keyStatus.textContent = 'ðŸ” Key Status: Expired';
                } else {
                  keyPanel.classList.add('deleted');
                  keyStatus.textContent = 'ðŸ” Key Status: Deleted';
                }
              } catch (e) {
                keyPanel.classList.remove('expired', 'deleted');
                keyStatus.textContent = 'ðŸ” Key Status: Not Activated';
              }
            } else {
              keyPanel.classList.remove('expired', 'deleted');
              keyStatus.textContent = 'ðŸ” Key Status: Not Activated';
            }
            
            keyToggleBtn.textContent = 'Activate';
            keyInfo.innerHTML = '<div class="key-info-item"><span class="key-info-value">Enter your activation key to authorize this authenticated user account for AI capabilities including photo analysis, advanced memory, and unlimited conversations with permanent UID-based activation.</span></div>';
          }
          
          if (!this.isActivated || this.isBlocked) {
            this.blockAIFunctionality();
          }
        }

        blockAIFunctionality() {
          if (window.streamAIResponse && !window.streamAIResponse._blocked) {
            window.originalStreamAIResponse = window.streamAIResponse;
            window.streamAIResponse = function() {
              appendMessage("ðŸ”’ Please activate your user key to use AI features. Click 'KEY' at the bottom or enter your activation key above.", 'ai', false, false);
              showToast('warning', 'User Activation Required', 'Please activate your user to access AI functionality.');
            };
            window.streamAIResponse._blocked = true;
          }
        }

        queueToast(type, title, message) {
          if (this.systemReady && this.initializationComplete) {
            showToast(type, title, message);
          }
        }

        async activateKey(key) {
          try {
            document.getElementById('key-submit-btn').disabled = true;
            document.getElementById('key-submit-btn').textContent = 'Activating...';
            
            await this.validateUIDBasedKey(key.toUpperCase());
            this.updateUI();
            
            document.getElementById('key-input').value = '';
            
            if (window.originalStreamAIResponse) {
              window.streamAIResponse = window.originalStreamAIResponse;
              delete window.streamAIResponse._blocked;
            }
          } catch (error) {
            showToast('error', 'Activation Failed', error.message);
            console.error('Key activation failed:', error);
          } finally {
            if (!this.isActivated) {
              document.getElementById('key-submit-btn').disabled = false;
              document.getElementById('key-submit-btn').textContent = 'Activate';
            }
          }
        }

        deactivateKey() {
          this.isActivated = false;
          this.keyData = null;
          this.clearUIDBasedActivation();
          
          if (this.realtimeListener) {
            this.realtimeListener();
            this.realtimeListener = null;
          }
          
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
            this.countdownInterval = null;
          }
          
          this.hideCountdown();
          this.hideBlockedOverlay();
          this.updateUI();
          showToast('info', 'Key Deactivated', 'UID-based authorization removed. Activate a key to continue using AI features.');
        }

        destroy() {
          if (this.realtimeListener) {
            this.realtimeListener();
          }
          
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
          
          this.hideBlockedOverlay();
          
          // Log performance stats
          console.log('Key System Performance Stats:', Object.fromEntries(this.performanceMonitor));
        }
      }

      // Initialize the authenticated UID-based key system
      let keySystem = new AuthenticatedKeySystem();

      // GoFile API Configuration - Performance Optimized
      const GOFILE_API_TOKEN = 'j4yXffP0QupranFzYZUY6DoKMLan7fw8';
      const GOFILE_BASE_URL = 'https://api.gofile.io';
      const UPLOAD_URL = 'https://upload.gofile.io/uploadfile';

      // Ultra-Optimized Cloud Storage Manager
      class UltraOptimizedGoFileStorage {
        constructor() {
          this.token = GOFILE_API_TOKEN;
          this.folderId = null;
          this.accountId = null;
          this.storageKey = 'ai_chatbot_data_uid_based';
          this.syncInProgress = false;
          this.lastSync = 0;
          this.syncInterval = 45000;
          this.retryAttempts = 3;
          this.retryDelay = 2000;
          this.dataFileId = null;
          this.initialized = false;
          this.isConnected = false;
          this.connectionCheckInterval = null;
          this.autoSyncInterval = null;
          this.performanceCache = new Map();
        }

        getUserUID() {
          return window.authManager?.getCurrentUser()?.uid || keySystem?.userUID;
        }

        updateConnectionStatus(connected, message = '') {
          const indicator = document.getElementById('connection-indicator');
          const text = document.getElementById('connection-text');
          
          this.isConnected = connected;
          
          if (connected) {
            indicator.classList.add('connected');
            text.textContent = 'GoFile Connected';
          } else {
            indicator.classList.remove('connected');
            text.textContent = message || 'GoFile Disconnected';
          }
        }

        showSyncStatus(message, show = true) {
          const syncStatus = document.getElementById('sync-status');
          const syncMessage = document.getElementById('sync-message');
          
          if (syncMessage) {
            syncMessage.textContent = message;
          }
          
          if (show) {
            syncStatus.classList.add('show');
          } else {
            setTimeout(() => syncStatus.classList.remove('show'), 2000);
          }
        }

        async initialize() {
          if (this.initialized) return this.isConnected;
          
          try {
            this.showSyncStatus('Connecting to GoFile cloud...');
            this.updateConnectionStatus(false, 'Connecting...');
            
            const accountResponse = await fetch(`${GOFILE_BASE_URL}/accounts/getid`, {
              headers: {
                'Authorization': `Bearer ${this.token}`
              }
            });
            
            if (!accountResponse.ok) {
              throw new Error(`GoFile authentication failed: ${accountResponse.status}`);
            }
            
            const accountData = await accountResponse.json();
            if (accountData.status !== 'ok') {
              throw new Error('GoFile authentication unsuccessful');
            }
            
            this.accountId = accountData.data.id;
            
            const storedFileId = this.getStoredFileId();
            if (storedFileId) {
              this.dataFileId = storedFileId;
            }
            
            this.initialized = true;
            this.updateConnectionStatus(true);
            this.showSyncStatus('Connected to GoFile cloud âœ“', false);
            
            showToast('success', 'Cloud Connected', 'GoFile cloud storage is now active');
            
            this.startConnectionMonitoring();
            this.startAutoSync();
            
            return true;
          } catch (error) {
            console.error('GoFile initialization failed:', error);
            this.updateConnectionStatus(false, 'Connection Failed');
            this.showSyncStatus('GoFile connection failed', false);
            showToast('error', 'Cloud Error', 'Failed to connect to GoFile. Please check your connection.');
            return false;
          }
        }

        getStoredFileId() {
          try {
            const userUID = this.getUserUID();
            if (!userUID) return null;
            
            return sessionStorage.getItem(`gofile_data_file_id_${userUID}`);
          } catch (e) {
            return null;
          }
        }

        setStoredFileId(fileId) {
          try {
            const userUID = this.getUserUID();
            if (!userUID) return;
            
            sessionStorage.setItem(`gofile_data_file_id_${userUID}`, fileId);
          } catch (e) {
            console.warn('Failed to store file ID');
          }
        }

        clearStoredData() {
          try {
            const userUID = this.getUserUID();
            if (!userUID) return;
            
            sessionStorage.removeItem(`gofile_data_file_id_${userUID}`);
            sessionStorage.removeItem(`gofile_folder_id_${userUID}`);
          } catch (e) {
            // Ignore errors
          }
          this.dataFileId = null;
          this.folderId = null;
        }

        async createDataFile(data) {
          try {
            const userData = window.authManager?.getCurrentUser();
            const userEmail = userData?.email || 'unknown';
            
            const jsonData = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `chatbot_data_${userEmail}_${timestamp}.json`;
            
            const formData = new FormData();
            formData.append('file', blob, fileName);
            
            if (this.folderId) {
              formData.append('folderId', this.folderId);
            }
            
            const uploadResponse = await fetch(UPLOAD_URL, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${this.token}`
              },
              body: formData
            });
            
            if (!uploadResponse.ok) {
              throw new Error(`Upload failed: ${uploadResponse.status}`);
            }
            
            const uploadData = await uploadResponse.json();
            
            if (uploadData.status === 'ok') {
              this.dataFileId = uploadData.data.fileId;
              this.setStoredFileId(this.dataFileId);
              
              if (!this.folderId && uploadData.data.parentFolder) {
                this.folderId = uploadData.data.parentFolder;
                try {
                  const userUID = this.getUserUID();
                  if (userUID) {
                    sessionStorage.setItem(`gofile_folder_id_${userUID}`, this.folderId);
                  }
                } catch (e) {
                  // Ignore storage errors
                }
              }
              
              return true;
            }
            
            throw new Error('Upload response unsuccessful');
          } catch (error) {
            console.error('Failed to create data file:', error);
            throw error;
          }
        }

        async updateDataFile(data) {
          if (this.dataFileId) {
            try {
              await fetch(`${GOFILE_BASE_URL}/contents`, {
                method: 'DELETE',
                headers: {
                  'Authorization': `Bearer ${this.token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  contentsId: this.dataFileId
                })
              });
            } catch (e) {
              console.warn('Failed to delete old file:', e);
            }
          }
          
          return await this.createDataFile(data);
        }

        async saveToCloud(data, isAutoSync = false) {
          if (this.syncInProgress) return false;
          
          this.syncInProgress = true;
          
          if (!isAutoSync) {
            this.showSyncStatus('Saving to GoFile cloud...');
          }
          
          if (!this.initialized) {
            const connected = await this.initialize();
            if (!connected) {
              this.syncInProgress = false;
              return false;
            }
          }
          
          let attempts = 0;
          while (attempts < this.retryAttempts) {
            try {
              const userProfile = window.authManager?.getUserProfile();
              const userData = window.authManager?.getCurrentUser();
              
              const saveData = {
                conversations: this.serializeMap(conversations),
                advancedMemory: {
                  conversations: this.serializeMap(advancedMemory.conversations, (conv) => ({
                    ...conv,
                    topics: Array.from(conv.topics),
                    messages: conv.messages
                  })),
                  globalTopics: this.serializeMap(advancedMemory.globalTopics, (convIds) => Array.from(convIds)),
                  conversationTopics: Array.from(advancedMemory.conversationTopics.entries())
                },
                currentConversationId,
                userInfo: {
                  uid: userData?.uid,
                  email: userData?.email,
                  displayName: userProfile?.displayName || userData?.displayName,
                  deviceInfo: window.authManager?.getDeviceInfo()
                },
                lastUpdated: Date.now(),
                version: '7.0',
                metadata: {
                  totalConversations: conversations.size,
                  totalMemoryEntries: advancedMemory.conversations.size,
                  saveType: isAutoSync ? 'auto' : 'manual',
                  authSystem: 'email-password-uid-based'
                }
              };
              
              const success = this.dataFileId ?
                  await this.updateDataFile(saveData) :
                  await this.createDataFile(saveData);
              
              if (success) {
                this.lastSync = Date.now();
                this.updateConnectionStatus(true);
                
                if (!isAutoSync) {
                  this.showSyncStatus('Saved to GoFile cloud âœ“', false);
                }
                
                this.syncInProgress = false;
                return true;
              }
            } catch (error) {
              attempts++;
              console.error(`Save attempt ${attempts} failed:`, error);
              
              if (attempts >= this.retryAttempts) {
                this.updateConnectionStatus(false, 'Save Failed');
                
                if (!isAutoSync) {
                  this.showSyncStatus('GoFile save failed', false);
                  showToast('error', 'Cloud Save Failed', 'Failed to save to GoFile cloud.');
                }
                
                this.syncInProgress = false;
                return false;
              } else {
                await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempts));
              }
            }
          }
          
          this.syncInProgress = false;
          return false;
        }

        async loadFromCloud() {
          if (!this.initialized) {
            const connected = await this.initialize();
            if (!connected) {
              return this.getEmptyData();
            }
          }
          
          if (!this.dataFileId) {
            this.showSyncStatus('No cloud backup found', false);
            return this.getEmptyData();
          }
          
          this.showSyncStatus('Loading from GoFile cloud...');
          
          try {
            const detailsResponse = await fetch(`${GOFILE_BASE_URL}/contents/${this.dataFileId}`, {
              headers: {
                'Authorization': `Bearer ${this.token}`
              }
            });
            
            if (!detailsResponse.ok) {
              throw new Error(`Failed to get file details: ${detailsResponse.status}`);
            }
            
            const detailsData = await detailsResponse.json();
            
            if (detailsData.status !== 'ok') {
              throw new Error('Failed to get file details from GoFile');
            }
            
            let fileInfo = null;
            if (detailsData.data.children) {
              fileInfo = Object.values(detailsData.data.children).find(child =>
                  child.id === this.dataFileId && child.type === 'file'
              );
            }
            
            if (!fileInfo || !fileInfo.link) {
              throw new Error('Data file not found or no download link');
            }
            
            const fileResponse = await fetch(fileInfo.link);
            if (!fileResponse.ok) {
              throw new Error(`Failed to download file: ${fileResponse.status}`);
            }
            
            const fileData = await fileResponse.json();
            
            this.showSyncStatus('Loaded from GoFile cloud âœ“', false);
            this.updateConnectionStatus(true);
            
            return fileData;
          } catch (error) {
            console.error('Failed to load from GoFile:', error);
            this.updateConnectionStatus(false, 'Load Failed');
            this.showSyncStatus('GoFile load failed', false);
            showToast('warning', 'Cloud Load Failed', 'Could not load from cloud storage.');
            return this.getEmptyData();
          }
        }

        serializeMap(map, valueTransformer = null) {
          const result = {};
          for (const [key, value] of map.entries()) {
            result[key] = valueTransformer ? valueTransformer(value) : value;
          }
          return result;
        }

        getEmptyData() {
          return {
            conversations: {},
            advancedMemory: {
              conversations: {},
              globalTopics: {},
              conversationTopics: []
            },
            currentConversationId: null,
            version: '7.0'
          };
        }

        startConnectionMonitoring() {
          if (this.connectionCheckInterval) {
            clearInterval(this.connectionCheckInterval);
          }
          
          this.connectionCheckInterval = setInterval(async () => {
            if (!this.initialized) return;
            
            try {
              const response = await fetch(`${GOFILE_BASE_URL}/accounts/getid`, {
                headers: { 'Authorization': `Bearer ${this.token}` }
              });
              
              const isConnected = response.ok;
              this.updateConnectionStatus(isConnected, isConnected ? null : 'Connection Lost');
            } catch (error) {
              this.updateConnectionStatus(false, 'Connection Error');
            }
          }, 60000);
        }

        startAutoSync() {
          if (this.autoSyncInterval) {
            clearInterval(this.autoSyncInterval);
          }
          
          this.autoSyncInterval = setInterval(async () => {
            if (this.isConnected && !this.syncInProgress &&
                Date.now() - this.lastSync > this.syncInterval) {
              await this.saveToCloud({
                conversations,
                advancedMemory,
                currentConversationId
              }, true);
            }
          }, this.syncInterval);
        }

        async clearAllData() {
          this.clearStoredData();
          this.lastSync = 0;
          this.updateConnectionStatus(this.initialized);
        }

        destroy() {
          if (this.connectionCheckInterval) {
            clearInterval(this.connectionCheckInterval);
          }
          if (this.autoSyncInterval) {
            clearInterval(this.autoSyncInterval);
          }
        }
      }

      // Initialize ultra-optimized cloud storage
      const cloudStorage = new UltraOptimizedGoFileStorage();

      // OpenRouter model list with vision capabilities
      const openRouterModels = [
        { id: "openrouter:01-ai/yi-large", hasVision: false },
        { id: "openrouter:anthropic/claude-3-haiku", hasVision: true },
        { id: "openrouter:anthropic/claude-3-opus", hasVision: true },
        { id: "openrouter:anthropic/claude-3-sonnet", hasVision: true },
        { id: "openrouter:anthropic/claude-3.5-haiku", hasVision: true },
        { id: "openrouter:anthropic/claude-3.5-sonnet", hasVision: true },
        { id: "openrouter:anthropic/claude-sonnet-4", hasVision: true },
        { id: "openrouter:anthropic/claude-opus-4", hasVision: true },
        { id: "openrouter:google/gemini-2.0-flash-001", hasVision: true },
        { id: "openrouter:google/gemini-flash-1.5", hasVision: true },
        { id: "openrouter:google/gemini-pro-1.5", hasVision: true },
        { id: "openrouter:google/gemma-2-27b-it", hasVision: false },
        { id: "openrouter:meta-llama/llama-3.2-11b-vision-instruct", hasVision: true },
        { id: "openrouter:meta-llama/llama-3.2-90b-vision-instruct", hasVision: true },
        { id: "openrouter:mistralai/pixtral-12b", hasVision: true },
        { id: "openrouter:mistralai/pixtral-large-2411", hasVision: true },
        { id: "openrouter:openai/gpt-4-turbo", hasVision: true },
        { id: "openrouter:openai/gpt-4o", hasVision: true },
        { id: "openrouter:openai/gpt-4o-mini", hasVision: true },
        { id: "openrouter:qwen/qwen-2.5-vl-7b-instruct", hasVision: true },
        { id: "openrouter:qwen/qwen-vl-max", hasVision: true },
        { id: "openrouter:deepseek/deepseek-chat", hasVision: false },
        { id: "openrouter:openai/chatgpt-4o-latest", hasVision: true },
        { id: "openrouter:microsoft/phi-4-multimodal-instruct", hasVision: true }
      ];

      // Image handling variables
      let attachedImages = [];
      const MAX_IMAGES = 5;
      const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

      // Ultra-optimized toast system
      function showToast(type, title, message, duration = 4000) {
        const toastContainer = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        const icons = {
          success: 'âœ“',
          error: 'âœ•',
          warning: 'âš ',
          info: 'â„¹'
        };

        toast.innerHTML = `
          <div class="toast-icon">${icons[type] || icons.info}</div>
          <div class="toast-content">
            <div class="toast-title">${title}</div>
            <div class="toast-message">${message}</div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">âœ•</button>
        `;

        toastContainer.appendChild(toast);

        // Trigger animation
        requestAnimationFrame(() => toast.classList.add('show'));

        // Auto remove
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // Authentication form handlers
      function setupAuthenticationHandlers() {
        const signinTab = document.getElementById('signin-tab');
        const signupTab = document.getElementById('signup-tab');
        const signinForm = document.getElementById('signin-form');
        const signupForm = document.getElementById('signup-form');
        const signinBtn = document.getElementById('signin-btn');
        const signupBtn = document.getElementById('signup-btn');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const deviceIdDisplay = document.getElementById('device-id-display');
        const userInfo = document.getElementById('user-info');
        const userDisplayName = document.getElementById('user-display-name');
        const signOutBtn = document.getElementById('sign-out-btn');

        // Display device ID
        if (deviceIdDisplay && window.authManager) {
          const deviceInfo = window.authManager.getDeviceInfo();
          deviceIdDisplay.textContent = deviceInfo.deviceID?.slice(0, 12) + '...' || 'Generating...';
        }

        // Tab switching
        signinTab.addEventListener('click', () => {
          signinTab.classList.add('active');
          signupTab.classList.remove('active');
          signinForm.classList.add('active');
          signupForm.classList.remove('active');
        });

        signupTab.addEventListener('click', () => {
          signupTab.classList.add('active');
          signinTab.classList.remove('active');
          signupForm.classList.add('active');
          signinForm.classList.remove('active');
        });

        // Sign in form handler
        signinForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          const email = document.getElementById('signin-email').value.trim();
          const password = document.getElementById('signin-password').value;
          
          if (!email || !password) {
            showToast('warning', 'Missing Information', 'Please enter both email and password.');
            return;
          }
          
          signinBtn.disabled = true;
          signinBtn.textContent = 'Signing In...';
          
          try {
            await window.authManager.signIn(email, password);
            // Success handled by auth state change listener
          } catch (error) {
            console.error('Sign-in error:', error);
            // Error already handled by authManager
          } finally {
            signinBtn.disabled = false;
            signinBtn.textContent = 'Sign In';
          }
        });

        // Sign up form handler
        signupForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          const name = document.getElementById('signup-name').value.trim();
          const email = document.getElementById('signup-email').value.trim();
          const password = document.getElementById('signup-password').value;
          const confirmPassword = document.getElementById('signup-confirm-password').value;
          
          if (!name || !email || !password || !confirmPassword) {
            showToast('warning', 'Missing Information', 'Please fill in all fields.');
            return;
          }
          
          signupBtn.disabled = true;
          signupBtn.textContent = 'Creating Account...';
          
          try {
            await window.authManager.signUp(email, password, confirmPassword, name);
            // Switch to sign-in form after successful signup
            signinTab.click();
          } catch (error) {
            console.error('Sign-up error:', error);
            // Error already handled by authManager
          } finally {
            signupBtn.disabled = false;
            signupBtn.textContent = 'Create Account';
          }
        });

        // Forgot password handler
        forgotPasswordLink.addEventListener('click', async (e) => {
          e.preventDefault();
          
          const email = document.getElementById('signin-email').value.trim();
          
          if (!email) {
            showToast('warning', 'Email Required', 'Please enter your email address first.');
            document.getElementById('signin-email').focus();
            return;
          }
          
          try {
            await window.authManager.resetPassword(email);
          } catch (error) {
            console.error('Password reset error:', error);
            // Error already handled by authManager
          }
        });

        // Sign out handler
        signOutBtn.addEventListener('click', async () => {
          try {
            await window.authManager.signOut();
            showToast('success', 'Signed Out', 'You have been successfully signed out.');
          } catch (error) {
            console.error('Sign-out error:', error);
            showToast('error', 'Sign Out Failed', 'Failed to sign out properly.');
          }
        });

        // User authentication event listener
        window.addEventListener('userAuthenticated', (event) => {
          const user = event.detail.user;
          const userProfile = window.authManager?.getUserProfile();
          
          if (userInfo && userDisplayName) {
            const displayName = userProfile?.displayName || user.displayName || user.email.split('@')[0];
            userDisplayName.textContent = `ðŸ‘‹ ${displayName} (${user.email})`;
            userInfo.style.display = 'flex';
          }
        });
      }

      // Theme management
      const themeToggle = document.getElementById('theme-toggle');
      const htmlElement = document.documentElement;

      function loadTheme() {
        const savedTheme = sessionStorage.getItem('theme') || 'light';
        htmlElement.setAttribute('data-theme', savedTheme);
        if (themeToggle) {
          themeToggle.checked = savedTheme === 'dark';
        }
      }

      function toggleTheme() {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        htmlElement.setAttribute('data-theme', newTheme);
        sessionStorage.setItem('theme', newTheme);
      }

      loadTheme();
      if (themeToggle) {
        themeToggle.addEventListener('change', toggleTheme);
      }

      // Chat functionality with performance optimizations
      const chatContainer = document.getElementById('chat-container');
      const userInput = document.getElementById('user-input');
      const sendBtn = document.getElementById('send-btn');
      const modelSelect = document.getElementById('model-select');
      const conversationSelect = document.getElementById('conversation-select');
      const newConversationBtn = document.getElementById('new-conversation-btn');
      const deleteConversationBtn = document.getElementById('delete-conversation-btn');
      const clearMemoryBtn = document.getElementById('clear-memory-btn');
      const memoryPanel = document.getElementById('memory-panel');
      const memoryContent = document.getElementById('memory-content');
      const fileInput = document.getElementById('file-input');
      const photoBtn = document.getElementById('photo-btn');
      const imagePreviewContainer = document.getElementById('image-preview-container');
      const imagePreviews = document.getElementById('image-previews');

      // Optimized image handling
      function handleImageSelect(e) {
        const files = Array.from(e.target.files);

        if (attachedImages.length + files.length > MAX_IMAGES) {
          showToast('warning', 'Too Many Images', `You can only attach up to ${MAX_IMAGES} images at once.`);
          return;
        }

        files.forEach(file => {
          if (!file.type.startsWith('image/')) {
            showToast('error', 'Invalid File', `${file.name} is not an image file.`);
            return;
          }

          if (file.size > MAX_FILE_SIZE) {
            showToast('error', 'File Too Large', `${file.name} exceeds the 10MB size limit.`);
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            attachedImages.push({
              file: file,
              dataUrl: e.target.result,
              name: file.name
            });
            updateImagePreviews();
          };
          reader.readAsDataURL(file);
        });

        if (fileInput) {
          fileInput.value = '';
        }
      }

      function updateImagePreviews() {
        if (!imagePreviews || !imagePreviewContainer) return;

        if (attachedImages.length === 0) {
          imagePreviewContainer.style.display = 'none';
          imagePreviews.innerHTML = '';
          return;
        }

        imagePreviewContainer.style.display = 'block';
        imagePreviews.innerHTML = attachedImages.map((img, index) => `
          <div class="image-preview-wrapper">
            <img src="${img.dataUrl}" alt="${img.name}" class="image-preview" onclick="openImageModal('${img.dataUrl}')">
            <button class="remove-image" onclick="removeImage(${index})" aria-label="Remove image">âœ•</button>
          </div>
        `).join('');
      }

      window.removeImage = function(index) {
        attachedImages.splice(index, 1);
        updateImagePreviews();
        showToast('info', 'Image Removed', 'Image has been removed from attachments.');
      };

      window.openImageModal = function(src) {
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        if (modal && modalImg) {
          modal.style.display = 'block';
          modalImg.src = src;
        }
      };

      window.closeImageModal = function() {
        const modal = document.getElementById('imageModal');
        if (modal) {
          modal.style.display = 'none';
        }
      };

      // Close modal when clicking outside
      if (window.onclick) {
        const originalOnclick = window.onclick;
        window.onclick = function(event) {
          const modal = document.getElementById('imageModal');
          if (event.target === modal) {
            closeImageModal();
          }
          if (originalOnclick) {
            originalOnclick(event);
          }
        };
      } else {
        window.onclick = function(event) {
          const modal = document.getElementById('imageModal');
          if (event.target === modal) {
            closeImageModal();
          }
        };
      }

      // Ultra-optimized advanced memory system
      let advancedMemory = {
        conversations: new Map(),
        globalTopics: new Map(),
        conversationTopics: new Map()
      };

      // Populate model selector
      function populateModelSelector() {
        if (!modelSelect) return;
        
        modelSelect.innerHTML = '<option value="" disabled selected>Select a model</option>';
        openRouterModels.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          const modelName = model.id.replace(/^openrouter:/, '');
          option.textContent = modelName + (model.hasVision ? ' ðŸ‘ï¸' : '');
          option.dataset.hasVision = model.hasVision;
          modelSelect.appendChild(option);
        });
      }

      // Conversation management with performance optimization
      let conversations = new Map();
      let currentConversationId = null;

      // Optimized topic extraction
      function extractTopicsFromText(text) {
        if (!text || typeof text !== 'string') return [];

        const topics = new Set();
        const lowerText = text.toLowerCase();

        const techKeywords = [
          'javascript', 'python', 'java', 'react', 'vue', 'angular', 'node', 'typescript',
          'html', 'css', 'sql', 'database', 'api', 'rest', 'graphql', 'git', 'docker',
          'kubernetes', 'aws', 'azure', 'programming', 'coding', 'development', 'software',
          'frontend', 'backend', 'fullstack', 'web', 'mobile', 'app', 'ai', 'machine learning',
          'image', 'photo', 'picture', 'vision', 'visual', 'analyze', 'detect', 'recognition'
        ];

        techKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            topics.add(keyword);
          }
        });

        const questionPatterns = ['how to', 'what is', 'why does', 'when should', 'where can', 'analyze this', 'look at'];
        questionPatterns.forEach(pattern => {
          if (lowerText.includes(pattern)) {
            const match = lowerText.match(new RegExp(pattern + ' ([a-z]+(?:\\s+[a-z]+){0,2})'));
            if (match && match[1]) {
              topics.add(match[1].trim());
            }
          }
        });

        return Array.from(topics).slice(0, 10);
      }

      function generateConversationTitle(firstMessage, hasImages = false) {
        if (!firstMessage || typeof firstMessage !== 'string') return hasImages ? 'Image Analysis' : 'New Conversation';

        const topics = extractTopicsFromText(firstMessage);
        if (topics.length > 0) {
          const prefix = hasImages ? 'ðŸ–¼ï¸ ' : '';
          return prefix + topics.slice(0, 2).map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
        }

        const prefix = hasImages ? 'ðŸ–¼ï¸ ' : '';
        return prefix + (firstMessage.substring(0, 50).trim() + (firstMessage.length > 50 ? '...' : '') || 'New Conversation');
      }

      function updateAdvancedMemory(userMessage, aiResponse, convId, images = []) {
        if (!userMessage || !aiResponse || !convId) return;

        const userTopics = extractTopicsFromText(userMessage);
        const aiTopics = extractTopicsFromText(aiResponse);
        if (images.length > 0) {
          userTopics.push('image', 'visual');
        }
        const allTopics = [...new Set([...userTopics, ...aiTopics])];

        if (!advancedMemory.conversations.has(convId)) {
          advancedMemory.conversations.set(convId, {
            id: convId,
            title: generateConversationTitle(userMessage, images.length > 0),
            messages: [],
            topics: new Set(),
            createdAt: new Date().toISOString(),
            lastUpdated: Date.now(),
            hasImages: images.length > 0
          });
        }

        const conv = advancedMemory.conversations.get(convId);

        allTopics.forEach(topic => {
          conv.topics.add(topic);

          if (!advancedMemory.globalTopics.has(topic)) {
            advancedMemory.globalTopics.set(topic, new Set());
          }
          advancedMemory.globalTopics.get(topic).add(convId);
        });

        conv.messages.push({
          user: userMessage,
          ai: aiResponse,
          timestamp: Date.now(),
          topics: allTopics,
          images: images
        });

        conv.lastUpdated = Date.now();
        if (images.length > 0) conv.hasImages = true;

        advancedMemory.conversationTopics.set(convId, Array.from(conv.topics));

        cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();
      }

      function getFullConversationHistory(convId) {
        const conv = advancedMemory.conversations.get(convId);
        if (!conv) return [];

        return conv.messages.map(msg => [
          { role: 'user', content: msg.user },
          { role: 'assistant', content: msg.ai }
        ]).flat();
      }

      function buildContextualPrompt(userInput, convId, images = []) {
        const conv = advancedMemory.conversations.get(convId);
        const recentHistory = conv ? conv.messages.slice(-5) : [];

        let contextPrompt = '';

        if (images.length > 0 && (!userInput || userInput.trim() === '')) {
          contextPrompt = `[IMAGE ANALYSIS REQUEST] The user has attached ${images.length} image(s) for analysis.\n\n`;
          contextPrompt += 'Please analyze the attached image(s) and provide detailed insights.';
        } else if (images.length > 0) {
          contextPrompt = `[USER MESSAGE WITH ${images.length} IMAGE(S)]\n\n`;

          if (recentHistory.length > 0) {
            contextPrompt += `[CONVERSATION CONTEXT] This conversation has ${conv.messages.length} previous exchanges. Topics discussed: ${Array.from(conv.topics).join(', ')}.  Recent conversation history: ${recentHistory.map(msg => `User: ${msg.user}\nAssistant: ${msg.ai.substring(0, 200)}...`).join('\n\n')}  [CURRENT MESSAGE]: ${userInput}  Please respond to the user's message while considering the attached image(s) and the conversation history.`;
          } else {
            contextPrompt += userInput;
          }
        } else {
          if (recentHistory.length > 0) {
            contextPrompt += `[CONVERSATION MEMORY] This conversation has ${conv.messages.length} previous exchanges. Topics discussed: ${Array.from(conv.topics).join(', ')}.  Recent conversation history: ${recentHistory.map(msg => `User: ${msg.user}\nAssistant: ${msg.ai.substring(0, 200)}...`).join('\n\n')}  [CURRENT QUESTION]: ${userInput}  Please provide a detailed response that takes into account the entire conversation history.`;
          } else {
            contextPrompt = userInput;
          }
        }

        return contextPrompt;
      }

      async function loadAdvancedMemory() {
        try {
          const cloudData = await cloudStorage.loadFromCloud();

          if (cloudData && cloudData.advancedMemory) {
            const parsed = cloudData.advancedMemory;

            advancedMemory.conversations = new Map();
            if (parsed.conversations) {
              Object.entries(parsed.conversations).forEach(([id, conv]) => {
                advancedMemory.conversations.set(id, {
                  ...conv,
                  topics: new Set(conv.topics || []),
                  messages: conv.messages || []
                });
              });
            }

            advancedMemory.globalTopics = new Map();
            if (parsed.globalTopics) {
              Object.entries(parsed.globalTopics).forEach(([topic, convIds]) => {
                advancedMemory.globalTopics.set(topic, new Set(convIds));
              });
            }

            advancedMemory.conversationTopics = new Map(parsed.conversationTopics || []);
          }
        } catch (e) {
          console.error('Error loading advanced memory:', e);
        }

        updateMemoryDisplay();
      }

      function updateMemoryDisplay() {
        if (!memoryPanel || !memoryContent) return;

        const hasMemory = advancedMemory.conversations.size > 0;

        if (!hasMemory) {
          memoryPanel.style.display = 'none';
          return;
        }

        memoryPanel.style.display = 'block';
        memoryContent.innerHTML = '';

        const topicCounts = new Map();
        advancedMemory.globalTopics.forEach((convIds, topic) => {
          topicCounts.set(topic, convIds.size);
        });

        const sortedTopics = Array.from(topicCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 15);

        if (sortedTopics.length > 0) {
          const topicsContainer = document.createElement('div');
          topicsContainer.innerHTML = '<div style="font-weight: 600; margin-bottom: 0.5rem;">Popular Topics:</div>';

          sortedTopics.forEach(([topic, count]) => {
            const tag = document.createElement('span');
            tag.className = 'topic-tag';
            tag.textContent = `${topic} (${count})`;
            tag.onclick = () => {
              if (userInput) {
                userInput.value = `Tell me more about ${topic}`;
                userInput.focus();
              }
            };
            topicsContainer.appendChild(tag);
          });

          memoryContent.appendChild(topicsContainer);
        }

        const recentConvs = Array.from(advancedMemory.conversations.values())
          .sort((a, b) => b.lastUpdated - a.lastUpdated)
          .slice(0, 3);

        if (recentConvs.length > 0) {
          recentConvs.forEach(conv => {
            const convDiv = document.createElement('div');
            convDiv.className = 'conversation-topic';
            convDiv.innerHTML = `
              <div class="conversation-title">${conv.title}</div>
              <div class="conversation-summary">${conv.messages.length} messages â€¢ ${Array.from(conv.topics).slice(0, 3).join(', ')}</div>
              <div class="conversation-date">${new Date(conv.createdAt).toLocaleDateString()}</div>
            `;
            convDiv.onclick = () => {
              currentConversationId = conv.id;
              if (conversationSelect) {
                conversationSelect.value = conv.id;
              }
              renderMessages();
            };
            memoryContent.appendChild(convDiv);
          });
        }
      }

      async function clearAdvancedMemory() {
        showToast('warning', 'Clear Memory', 'This will permanently delete all conversation memory. Are you sure?', 5000);

        const confirmToast = document.createElement('div');
        confirmToast.className = 'toast warning show';
        confirmToast.innerHTML = `
          <div class="toast-icon">âš </div>
          <div class="toast-content">
            <div class="toast-title">Confirm Clear Memory</div>
            <div class="toast-message">
              <div style="margin-bottom: 0.5rem;">This cannot be undone!</div>
              <button onclick="confirmClearMemory(this)" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; cursor: pointer;">Clear All</button>
              <button onclick="this.closest('.toast').remove()" style="background: #6b7280; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer;">Cancel</button>
            </div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">âœ•</button>
        `;

        document.getElementById('toast-container').appendChild(confirmToast);
      }

      window.confirmClearMemory = async function(button) {
        advancedMemory = {
          conversations: new Map(),
          globalTopics: new Map(),
          conversationTopics: new Map()
        };

        await cloudStorage.clearAllData();
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();

        button.closest('.toast').remove();
        showToast('success', 'Memory Cleared', 'All conversation memory has been successfully cleared.');
        if (chatContainer) {
          appendMessage('ðŸ§  Advanced memory has been cleared.', 'ai', false, false);
        }
      };

      // Optimized conversation management
      async function loadConversations() {
        try {
          const cloudData = await cloudStorage.loadFromCloud();

          if (cloudData) {
            if (cloudData.conversations) {
              conversations = new Map(Object.entries(cloudData.conversations));
            }

            if (cloudData.currentConversationId) {
              currentConversationId = cloudData.currentConversationId;
            }
          }
        } catch (e) {
          console.error('Failed to load conversations:', e);
        }

        if (conversations.size === 0) {
          createNewConversation();
        } else {
          if (!currentConversationId) {
            currentConversationId = Array.from(conversations.keys())[0];
          }
          updateConversationSelect();
          renderMessages();
        }

        await loadAdvancedMemory();
      }

      async function createNewConversation() {
        const id = `conv_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        conversations.set(id, []);
        currentConversationId = id;
        updateConversationSelect();
        renderMessages();
        if (chatContainer) {
          appendMessage('ðŸ‘‹ Welcome to a new conversation! I can analyze images and remember all our previous chats. What would you like to discuss?', 'ai', false, false);
        }
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        showToast('success', 'New Conversation', 'Started a new conversation with full memory context.');
      }

      async function deleteConversation() {
        if (!currentConversationId || conversations.size <= 1) {
          showToast('warning', 'Cannot Delete', 'Cannot delete the last conversation.');
          return;
        }

        const conv = advancedMemory.conversations.get(currentConversationId);
        const title = conv ? conv.title : 'this conversation';

        const confirmToast = document.createElement('div');
        confirmToast.className = 'toast error show';
        confirmToast.innerHTML = `
          <div class="toast-icon">ðŸ—‘ï¸</div>
          <div class="toast-content">
            <div class="toast-title">Delete Conversation</div>
            <div class="toast-message">
              <div style="margin-bottom: 0.5rem;">Delete "${title}"?</div>
              <button onclick="confirmDeleteConversation(this)" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; cursor: pointer;">Delete</button>
              <button onclick="this.closest('.toast').remove()" style="background: #6b7280; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer;">Cancel</button>
            </div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">âœ•</button>
        `;

        document.getElementById('toast-container').appendChild(confirmToast);
      }

      window.confirmDeleteConversation = async function(button) {
        const conv = advancedMemory.conversations.get(currentConversationId);
        const title = conv ? conv.title : 'Conversation';

        advancedMemory.conversations.delete(currentConversationId);
        conversations.delete(currentConversationId);
        currentConversationId = Array.from(conversations.keys())[0];
        updateConversationSelect();
        renderMessages();
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();
        button.closest('.toast').remove();
        showToast('success', 'Conversation Deleted', `"${title}" has been successfully deleted.`);
      };

      function updateConversationSelect() {
        if (!conversationSelect) return;

        conversationSelect.innerHTML = '';
        Array.from(conversations.keys()).forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          const conv = advancedMemory.conversations.get(id);
          const title = conv
              ? conv.title.substring(0, 30) + (conv.title.length > 30 ? '...' : '')
            : `Conversation ${id.slice(-4)}`;
          option.textContent = title;
          conversationSelect.appendChild(option);
        });
        conversationSelect.value = currentConversationId;
        if (deleteConversationBtn) {
          deleteConversationBtn.disabled = conversations.size <= 1;
        }
      }

      function renderMessages() {
        if (!chatContainer) return;

        chatContainer.innerHTML = '';
        const messages = conversations.get(currentConversationId) || [];
        
        let messageIndex = 0;
        
        function renderNextMessage() {
          if (messageIndex < messages.length) {
            const msg = messages[messageIndex];
            if (msg.images && msg.images.length > 0 && msg.role === 'user') {
              appendMessage(msg.content, msg.role, false, msg.role === 'user', msg.images);
            } else {
              appendMessage(msg.content, msg.role, false, msg.role === 'user');
            }
            messageIndex++;
            requestAnimationFrame(renderNextMessage);
          } else {
            requestAnimationFrame(() => scrollToBottom());
          }
        }
        
        renderNextMessage();
      }

      function formatTimestamp() {
        return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      function detectLanguage(code) {
        const langPatterns = [
          { pattern: /(?:import|export|function|const|let|var|=>|\{|\})/g, lang: 'javascript' },
          { pattern: /(?:def\s|import\s|from\s|class\s|if\s.*:|for\s.*:|while\s.*:)/g, lang: 'python' },
          { pattern: /(?:public\s|private\s|protected\s|class\s|interface\s|import\s|package\s)/g, lang: 'java' },
          { pattern: /(?:#include|int\s|char\s|float\s|double\s|void\s|struct\s)/g, lang: 'cpp' },
          { pattern: /(?:SELECT|FROM|WHERE|INSERT|UPDATE|DELETE|CREATE|DROP)/gi, lang: 'sql' },
          { pattern: /(?:<html|<head|<body|<div|<span|<p>)/gi, lang: 'html' },
          { pattern: /(?:\.|\#)[a-zA-Z][a-zA-Z0-9-]*\s*\{|@media|@import/g, lang: 'css' },
          { pattern: /(?:\$[a-zA-Z_][a-zA-Z0-9_]*|<\?php|\?>|echo\s|print\s)/g, lang: 'php' }
        ];

        for (const { pattern, lang } of langPatterns) {
          if (pattern.test(code)) return lang;
        }

        return 'text';
      }

      function copyToClipboard(text, button) {
        navigator.clipboard.writeText(text).then(() => {
          const originalText = button.textContent;
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
          }, 2000);
          showToast('success', 'Copied', 'Text copied to clipboard successfully.');
        }).catch(err => {
          console.error('Failed to copy:', err);
          button.textContent = 'Failed!';
          setTimeout(() => button.textContent = 'Copy', 2000);
          showToast('error', 'Copy Failed', 'Failed to copy text to clipboard.');
        });
      }

      function parseMessageContent(text) {
        const container = document.createElement('div');
        container.className = 'message-content';
        const parts = text.split(/(```[\s\S]*?```)/g);

        parts.forEach(part => {
          if (part.match(/^```[\s\S]*```$/)) {
            const codeMatch = part.match(/^```(\w*)\n?([\s\S]*?)\n?```$/);
            const language = codeMatch?.[1] || 'text';
            const code = codeMatch?.[2] || part.replace(/^```|```$/g, '');

            const codeBlock = document.createElement('div');
            codeBlock.className = 'code-block';

            const header = document.createElement('div');
            header.className = 'code-block-header';
            header.innerHTML = `<span>${language || 'Code'}</span>`;

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy Code';
            copyBtn.onclick = (e) => {
              e.stopPropagation();
              copyToClipboard(code, copyBtn);
            };
            header.appendChild(copyBtn);

            const pre = document.createElement('pre');
            const codeElement = document.createElement('code');
            codeElement.textContent = code;

            if (language && hljs.getLanguage && hljs.getLanguage(language)) {
              codeElement.className = `language-${language}`;
              hljs.highlightElement(codeElement);
            } else {
              const detectedLang = detectLanguage(code);
              if (detectedLang !== 'text' && hljs.getLanguage && hljs.getLanguage(detectedLang)) {
                codeElement.className = `language-${detectedLang}`;
                hljs.highlightElement(codeElement);
              }
            }

            pre.appendChild(codeElement);
            codeBlock.appendChild(header);
            codeBlock.appendChild(pre);
            container.appendChild(codeBlock);
          } else {
            const inlineParts = part.split(/(`[^`]+`)/g);
            inlineParts.forEach(inlinePart => {
              if (inlinePart.match(/^`[^`]+`$/)) {
                const code = inlinePart.slice(1, -1);
                const inlineCode = document.createElement('span');
                inlineCode.className = 'inline-code';
                inlineCode.textContent = code;
                
                const smallCopyBtn = document.createElement('button');
                smallCopyBtn.className = 'copy-btn-small';
                smallCopyBtn.innerHTML = 'ðŸ“‹';
                smallCopyBtn.title = 'Copy inline code';
                smallCopyBtn.onclick = (e) => {
                  e.stopPropagation();
                  copyToClipboard(code, smallCopyBtn);
                };
                
                inlineCode.appendChild(smallCopyBtn);
                container.appendChild(inlineCode);
              } else if (inlinePart) {
                container.appendChild(document.createTextNode(inlinePart));
              }
            });
          }
        });

        return container;
      }

      function appendMessage(text, className, isTyping = false, showTimestamp = true, images = []) {
        if (!chatContainer) return null;

        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${className}${isTyping ? ' typing-indicator' : ''}`;
        msgDiv.style.transform = 'translateY(20px)';
        msgDiv.style.opacity = '0';

        if (!isTyping) {
          if (images && images.length > 0 && className === 'user') {
            const imageContainer = document.createElement('div');
            imageContainer.style.marginBottom = '0.5rem';

            images.forEach(img => {
              const imgElement = document.createElement('img');
              imgElement.src = img.dataUrl;
              imgElement.alt = img.name || 'Attached image';
              imgElement.className = 'message-image';
              imgElement.onclick = () => openImageModal(img.dataUrl);
              imageContainer.appendChild(imgElement);
            });

            msgDiv.appendChild(imageContainer);
          }

          const contentDiv = parseMessageContent(text);
          if (className === 'ai') {
            const fullCopyBtn = document.createElement('button');
            fullCopyBtn.className = 'copy-btn-inline';
            fullCopyBtn.textContent = 'Copy All';
            fullCopyBtn.onclick = (e) => {
              e.stopPropagation();
              copyToClipboard(text, fullCopyBtn);
            };
            contentDiv.appendChild(fullCopyBtn);
          }
          msgDiv.appendChild(contentDiv);

          if (showTimestamp && className === 'user') {
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = formatTimestamp();
            msgDiv.appendChild(timestamp);
          }
        }

        chatContainer.appendChild(msgDiv);
        
        requestAnimationFrame(() => {
          msgDiv.style.transform = 'translateY(0)';
          msgDiv.style.opacity = '1';
          msgDiv.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          scrollToBottom();
        });
        
        return msgDiv;
      }

      function updateMessageContent(msgDiv, text) {
        if (!msgDiv) return;

        const contentDiv = msgDiv.querySelector('.message-content') || document.createElement('div');
        contentDiv.className = 'message-content';
        msgDiv.innerHTML = '';
        const newContent = parseMessageContent(text);

        const fullCopyBtn = document.createElement('button');
        fullCopyBtn.className = 'copy-btn-inline';
        fullCopyBtn.textContent = 'Copy All';
        fullCopyBtn.onclick = (e) => {
          e.stopPropagation();
          copyToClipboard(text, fullCopyBtn);
        };

        newContent.appendChild(fullCopyBtn);
        msgDiv.appendChild(newContent);
        
        requestAnimationFrame(() => scrollToBottom());
      }

      function scrollToBottom() {
        if (!chatContainer) return;

        requestAnimationFrame(() => {
          chatContainer.scrollTo({
            top: chatContainer.scrollHeight,
            behavior: 'smooth'
          });
        });
      }

      // Ultra-optimized AI response streaming
      window.streamAIResponse = async function(prompt, images = []) {
        try {
          if (!prompt && images.length === 0) throw new Error('Please provide a message or attach images');
          if (!currentConversationId) throw new Error('No conversation selected');
          if (!modelSelect || !modelSelect.value) throw new Error('No model selected');

          const selectedOption = modelSelect.options[modelSelect.selectedIndex];
          const hasVision = selectedOption.dataset.hasVision === 'true';

          if (images.length > 0 && !hasVision) {
            throw new Error('Selected model does not support image analysis. Please choose a model with ðŸ‘ï¸ icon.');
          }

          if (userInput) userInput.disabled = true;
          if (sendBtn) sendBtn.disabled = true;
          if (photoBtn) photoBtn.disabled = true;

          const contextualPrompt = buildContextualPrompt(prompt, currentConversationId, images);
          const displayMessage = prompt || (images.length > 0 ? 'Analyze these images' : '');

          const userMessage = {
            role: 'user',
            content: displayMessage,
            timestamp: formatTimestamp(),
            images: images.map(img => ({ dataUrl: img.dataUrl, name: img.name }))
          };
          const currentMessages = conversations.get(currentConversationId) || [];
          currentMessages.push(userMessage);
          conversations.set(currentConversationId, currentMessages);
          appendMessage(displayMessage, 'user', false, true, images);
          await cloudStorage.saveToCloud({
            conversations,
            advancedMemory,
            currentConversationId
          });

          attachedImages = [];
          updateImagePreviews();

          const typingDiv = appendMessage('', 'ai', true, false);
          const selectedModel = modelSelect.value;

          const messages = [];

          const fullHistory = getFullConversationHistory(currentConversationId);
          fullHistory.forEach(msg => {
            messages.push({
              role: msg.role === 'assistant' ? 'assistant' : 'user',
              content: msg.content
            });
          });

          if (images.length > 0) {
            const imageContents = images.map(img => ({
              type: 'image_url',
              image_url: {
                url: img.dataUrl
              }
            }));

            messages.push({
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: contextualPrompt
                },
                ...imageContents
              ]
            });
          } else {
            messages.push({
              role: 'user',
              content: contextualPrompt
            });
          }

          const response = await puter.ai.chat(messages, {
            model: selectedModel,
            stream: true
          });

          if (typingDiv) {
            typingDiv.remove();
          }

          const aiMsgDiv = document.createElement('div');
          aiMsgDiv.className = 'message ai';
          aiMsgDiv.style.transform = 'translateY(20px)';
          aiMsgDiv.style.opacity = '0';
          if (chatContainer) {
            chatContainer.appendChild(aiMsgDiv);
          }
          
          requestAnimationFrame(() => {
            aiMsgDiv.style.transform = 'translateY(0)';
            aiMsgDiv.style.opacity = '1';
            aiMsgDiv.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          });
          
          let fullResponse = '';

          for await (const part of response) {
            if (part?.text) {
              fullResponse += part.text;
              updateMessageContent(aiMsgDiv, fullResponse);
            }
          }

          const aiMessage = { role: 'ai', content: fullResponse, timestamp: formatTimestamp() };
          currentMessages.push(aiMessage);
          conversations.set(currentConversationId, currentMessages);

          updateAdvancedMemory(displayMessage, fullResponse, currentConversationId, images);

          await cloudStorage.saveToCloud({
            conversations,
            advancedMemory,
            currentConversationId
          });
          updateConversationSelect();
        } catch (error) {
          console.error('Error:', error);

          const typingIndicators = document.querySelectorAll('.typing-indicator');
          typingIndicators.forEach(indicator => indicator.remove());

          const errorMsg = error.message || 'Something went wrong. Please try again.';
          appendMessage(`Error: ${errorMsg}`, 'ai', false, false);
          showToast('error', 'AI Error', errorMsg);
        } finally {
          if (userInput) userInput.disabled = false;
          if (sendBtn) sendBtn.disabled = false;
          if (photoBtn) photoBtn.disabled = false;
          if (userInput) userInput.focus();
        }
      };

      function handleSend() {
        if (!userInput || !sendBtn || sendBtn.disabled) return;

        const text = userInput.value.trim();
        if (text || attachedImages.length > 0) {
          const imagesToSend = [...attachedImages];
          streamAIResponse(text, imagesToSend);
          userInput.value = '';
        }
      }

      // Event listeners with performance optimization
      if (sendBtn) {
        sendBtn.onclick = handleSend;
      }
      
      if (userInput) {
        userInput.addEventListener('keydown', e => {
          if (e.key === 'Enter' && sendBtn && !sendBtn.disabled) handleSend();
        });
      }

      if (photoBtn && fileInput) {
        photoBtn.onclick = () => fileInput.click();
        fileInput.addEventListener('change', handleImageSelect);
      }

      if (newConversationBtn) {
        newConversationBtn.onclick = createNewConversation;
      }
      
      if (deleteConversationBtn) {
        deleteConversationBtn.onclick = deleteConversation;
      }
      
      if (clearMemoryBtn) {
        clearMemoryBtn.onclick = clearAdvancedMemory;
      }
      
      if (conversationSelect) {
        conversationSelect.onchange = () => {
          currentConversationId = conversationSelect.value;
          renderMessages();
        };
      }

      // Enhanced cleanup with performance monitoring
      window.addEventListener('beforeunload', () => {
        if (cloudStorage) {
          cloudStorage.destroy();
        }
        if (keySystem) {
          keySystem.destroy();
        }
      });

      // Global functions for UI interaction
      window.toggleKeyPanel = function() {
        const keyDetails = document.getElementById('key-details');
        if (keyDetails) {
          keyDetails.classList.toggle('show');

          if (keySystem && keySystem.isActivated) {
            keySystem.updateUI();
          }
        }
      };

      window.activateKey = function() {
        const keyInput = document.getElementById('key-input');
        if (!keyInput) return;

        const key = keyInput.value.trim();

        if (!key) {
          showToast('warning', 'Empty Key', 'Please enter an activation key.');
          return;
        }

        if (keySystem) {
          keySystem.activateKey(key);
        }
      };

      // Enhanced key input handling
      const keyInput = document.getElementById('key-input');
      if (keyInput) {
        keyInput.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
            activateKey();
          }
        });
      }

      // Setup authentication handlers
      setupAuthenticationHandlers();

      // Initialize all systems with performance tracking
      const initStartTime = performance.now();
      
      populateModelSelector();
      loadConversations().then(() => {
        if (userInput) {
          userInput.focus();
        }
        const initEndTime = performance.now();
        console.log(`Complete initialization time: ${(initEndTime - initStartTime).toFixed(2)}ms`);
        console.log('UID-based key system active with email/password authentication and device restrictions');
      });
    }

    // Start ultra-optimized initialization
    initializeApp();
  </script>
</body>
</html>