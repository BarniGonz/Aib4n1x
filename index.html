<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot with Photo Analysis & Advanced Memory - Powered by Barni</title>
  
  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, collection, doc, getDoc, setDoc, updateDoc, query, where, getDocs, deleteDoc, Timestamp, serverTimestamp, onSnapshot } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCmDLSB0S_0qnrcl5tsaSVyRQaopy8M12I",
      authDomain: "aib4n1x.firebaseapp.com",
      projectId: "aib4n1x",
      storageBucket: "aib4n1x.firebasestorage.app",
      messagingSenderId: "318019512167",
      appId: "1:318019512167:web:9dae7a6654bf7a9fbd31c2",
      measurementId: "G-4W0QEKN332"
    };

    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getFirestore(app);
    const auth = getAuth(app);

    // ULTRA-PERSISTENT UID MANAGEMENT SYSTEM WITH INDEXEDDB
    class UltraPersistentUIDManager {
      constructor() {
        this.uidStorageKeys = {
          primary: 'firebase_ultra_persistent_uid_v7_primary',
          backup: 'firebase_ultra_persistent_uid_v7_backup', 
          emergency: 'firebase_ultra_persistent_uid_v7_emergency',
          session: 'firebase_ultra_persistent_uid_v7_session',
          metadata: 'firebase_uid_metadata_v7',
          indexedDB: 'uid_store_v7'
        };
        this.persistentUID = null;
        this.isAuthInitialized = false;
        this.authLocked = false;
        this.initializationPromise = null;
        this.deviceFingerprint = null;
        this.indexedDBReady = false;
        this.initializeIndexedDB();
        this.createStableDeviceFingerprint();
      }

      // Initialize IndexedDB for primary storage
      async initializeIndexedDB() {
        try {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open('UltraPersistentUID', 1);
            
            request.onerror = () => {
              console.warn('IndexedDB not available, using localStorage fallback');
              this.indexedDBReady = false;
              resolve();
            };
            
            request.onsuccess = (event) => {
              this.indexedDB = event.target.result;
              this.indexedDBReady = true;
              console.log('IndexedDB initialized for ultra-persistent UID storage');
              resolve();
            };
            
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains('uids')) {
                const store = db.createObjectStore('uids', { keyPath: 'id' });
                store.createIndex('timestamp', 'timestamp', { unique: false });
                store.createIndex('version', 'version', { unique: false });
              }
            };
          });
        } catch (error) {
          console.warn('IndexedDB initialization failed:', error);
          this.indexedDBReady = false;
        }
      }

      // Create more stable device fingerprint
      createStableDeviceFingerprint() {
        try {
          // Use only stable properties that don't change with minor variations
          const stableProps = {
            screen: `${screen.width}x${screen.height}x${screen.colorDepth}`,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            language: navigator.language,
            platform: navigator.platform,
            // Use only the first part of userAgent for stability
            userAgentCore: navigator.userAgent.split(' ')[0] || 'unknown',
            hardwareConcurrency: navigator.hardwareConcurrency || 0,
            maxTouchPoints: navigator.maxTouchPoints || 0,
            cookieEnabled: navigator.cookieEnabled,
            version: 'v7'
          };

          // Create canvas fingerprint but truncate for stability
          const canvas = document.createElement('canvas');
          canvas.width = 200;
          canvas.height = 50;
          const ctx = canvas.getContext('2d');
          ctx.textBaseline = 'top';
          ctx.font = '14px Arial';
          ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
          ctx.fillText('Ultra-persistent fingerprint', 2, 2);
          ctx.fillStyle = 'rgba(255, 0, 102, 0.7)';
          ctx.fillText('Device identification', 4, 20);

          stableProps.canvasHash = btoa(canvas.toDataURL()).slice(0, 32);

          this.deviceFingerprint = btoa(JSON.stringify(stableProps));
          console.log('Created stable device fingerprint');
        } catch (e) {
          console.warn('Fingerprint creation failed, using fallback');
          this.deviceFingerprint = btoa(`fallback_${Date.now()}_v7`);
        }
      }

      // Get UID from IndexedDB first, then fallback to other storage
      async getUltraPersistentUID() {
        const sources = [
          () => this.getFromIndexedDB(),
          () => this.getFromStorage(sessionStorage, this.uidStorageKeys.session),
          () => this.getFromStorage(localStorage, this.uidStorageKeys.primary),
          () => this.getFromStorage(localStorage, this.uidStorageKeys.backup),
          () => this.getFromStorage(localStorage, this.uidStorageKeys.emergency)
        ];

        for (const getSource of sources) {
          try {
            const uid = await getSource();
            if (uid && typeof uid === 'string' && uid.length > 10) {
              console.log('Ultra-persistent UID recovered:', uid.slice(0, 8) + '...');
              return uid;
            }
          } catch (e) {
            continue;
          }
        }

        return null;
      }

      // Get UID from IndexedDB
      async getFromIndexedDB() {
        if (!this.indexedDBReady || !this.indexedDB) {
          return null;
        }

        return new Promise((resolve) => {
          try {
            const transaction = this.indexedDB.transaction(['uids'], 'readonly');
            const store = transaction.objectStore('uids');
            const request = store.get('primary');

            request.onsuccess = () => {
              const result = request.result;
              if (result && this.validateUIDData(result)) {
                resolve(result.uid);
              } else {
                resolve(null);
              }
            };

            request.onerror = () => resolve(null);
          } catch (e) {
            resolve(null);
          }
        });
      }

      // Get UID from localStorage/sessionStorage
      getFromStorage(storage, key) {
        try {
          const data = storage.getItem(key);
          if (data) {
            const parsed = JSON.parse(data);
            if (this.validateUIDData(parsed)) {
              return parsed.uid;
            }
          }
        } catch (e) {
          // Continue to next source
        }
        return null;
      }

      // Enhanced UID validation with more flexible fingerprint matching
      validateUIDData(data) {
        if (!data || !data.uid || !data.version) {
          return false;
        }

        // Version compatibility check
        if (data.version !== 'v7' && !data.version.startsWith('v6')) {
          return false;
        }

        // UID format validation
        if (typeof data.uid !== 'string' || data.uid.length < 10) {
          return false;
        }

        // Flexible fingerprint validation - allow for minor changes
        if (data.deviceFingerprint && this.deviceFingerprint) {
          try {
            const storedFP = JSON.parse(atob(data.deviceFingerprint));
            const currentFP = JSON.parse(atob(this.deviceFingerprint));
            
            // Check core stable properties
            const coreMatch = storedFP.platform === currentFP.platform &&
                             storedFP.timezone === currentFP.timezone &&
                             storedFP.language === currentFP.language;
            
            if (!coreMatch) {
              console.log('Core device properties changed, but allowing for minor variations');
              // Still allow but with warning
            }
          } catch (e) {
            console.log('Fingerprint validation failed, but allowing UID recovery');
          }
        }

        return true;
      }

      // Store UID in IndexedDB first, then redundant storage
      async setUltraPersistentUID(uid) {
        if (!uid) return;

        const uidData = {
          id: 'primary',
          uid: uid,
          timestamp: Date.now(),
          version: 'v7',
          deviceFingerprint: this.deviceFingerprint,
          authMethod: 'anonymous',
          permanent: true,
          ultrapersistent: true
        };

        const serialized = JSON.stringify(uidData);

        // Primary storage: IndexedDB
        if (this.indexedDBReady && this.indexedDB) {
          try {
            const transaction = this.indexedDB.transaction(['uids'], 'readwrite');
            const store = transaction.objectStore('uids');
            await store.put(uidData);
            console.log('UID stored in IndexedDB with ultra-persistence');
          } catch (e) {
            console.warn('IndexedDB storage failed:', e);
          }
        }

        // Redundant storage layers
        try {
          localStorage.setItem(this.uidStorageKeys.primary, serialized);
          localStorage.setItem(this.uidStorageKeys.backup, serialized);
          localStorage.setItem(this.uidStorageKeys.emergency, serialized);
          sessionStorage.setItem(this.uidStorageKeys.session, serialized);

          // Enhanced metadata
          localStorage.setItem(this.uidStorageKeys.metadata, JSON.stringify({
            lastStored: Date.now(),
            version: 'v7',
            fingerprint: this.deviceFingerprint,
            storageMethod: 'ultra-persistent-multi-layer'
          }));

          console.log('UID stored with ultra-persistent redundancy:', uid.slice(0, 8) + '...');
        } catch (e) {
          console.warn('Storage failed for UID persistence:', e);
        }

        this.persistentUID = uid;
      }

      async initializeAuthentication() {
        if (this.initializationPromise) {
          return this.initializationPromise;
        }

        this.initializationPromise = this._doInitializeAuthentication();
        return this.initializationPromise;
      }

      async _doInitializeAuthentication() {
        if (this.isAuthInitialized || this.authLocked) {
          return;
        }

        this.authLocked = true;
        console.log('Initializing ultra-persistent authentication...');

        try {
          // Wait for IndexedDB to be ready
          if (!this.indexedDBReady) {
            await this.initializeIndexedDB();
          }

          // Check for existing persistent UID with enhanced recovery
          const existingUID = await this.getUltraPersistentUID();

          if (existingUID) {
            console.log('Found existing persistent UID - maintaining session:', existingUID.slice(0, 8) + '...');
            this.persistentUID = existingUID;
            window.firebaseUser = { uid: existingUID };
            this.isAuthInitialized = true;
            this.authLocked = false;
            window.dispatchEvent(new CustomEvent('userAuthenticated', {
              detail: { uid: existingUID }
            }));
            return;
          }

          // Only authenticate if no persistent UID exists
          console.log('No persistent UID found - performing initial authentication');

          const userCredential = await signInAnonymously(auth);
          const uid = userCredential.user.uid;

          console.log('Initial anonymous sign-in successful:', uid.slice(0, 8) + '...');

          // Store UID with enhanced persistence
          await this.setUltraPersistentUID(uid);
          this.isAuthInitialized = true;

          window.firebaseUser = userCredential.user;
          window.dispatchEvent(new CustomEvent('userAuthenticated', {
            detail: userCredential.user
          }));

        } catch (error) {
          console.error('Authentication initialization failed:', error);

          // Enhanced fallback recovery
          const fallbackUID = await this.getUltraPersistentUID();
          if (fallbackUID) {
            console.log('Using enhanced fallback persistent UID');
            this.persistentUID = fallbackUID;
            window.firebaseUser = { uid: fallbackUID };
            window.dispatchEvent(new CustomEvent('userAuthenticated', {
              detail: { uid: fallbackUID }
            }));
          }
        } finally {
          this.authLocked = false;
          this.isAuthInitialized = true;
        }
      }

      getCurrentUID() {
        return this.persistentUID ||
               auth.currentUser?.uid ||
               null;
      }

      // Enhanced recovery mechanism
      async recoverUID() {
        console.log('Attempting UID recovery from all available sources...');
        
        const recoveredUID = await this.getUltraPersistentUID();
        if (recoveredUID) {
          this.persistentUID = recoveredUID;
          window.firebaseUser = { uid: recoveredUID };
          console.log('UID successfully recovered:', recoveredUID.slice(0, 8) + '...');
          return recoveredUID;
        }
        
        console.log('No UID could be recovered from any storage source');
        return null;
      }
    }

    // Initialize the ultra-persistent UID manager
    const uidManager = new UltraPersistentUIDManager();

    // FIXED: Enhanced auth state listener that prevents UID changes
    onAuthStateChanged(auth, (user) => {
      const existingUID = uidManager.persistentUID;

      if (user && user.uid) {
        console.log('Firebase auth state changed:', user.uid.slice(0, 8) + '...');

        // CRITICAL FIX: Always prioritize existing persistent UID
        if (existingUID) {
          console.log('Maintaining existing persistent UID over Firebase auth change');
          window.firebaseUser = { uid: existingUID };
          uidManager.persistentUID = existingUID;
        } else {
          // Only store new UID if no persistent UID exists
          console.log('Storing new Firebase UID as persistent');
          uidManager.setUltraPersistentUID(user.uid);
          window.firebaseUser = user;
        }

        window.dispatchEvent(new CustomEvent('userAuthenticated', {
          detail: window.firebaseUser
        }));
      } else if (existingUID && !uidManager.authLocked) {
        // Always maintain persistent UID even when Firebase auth is lost
        console.log('Firebase auth lost but maintaining persistent UID:', existingUID.slice(0, 8) + '...');
        window.firebaseUser = { uid: existingUID };
        window.dispatchEvent(new CustomEvent('userAuthenticated', {
          detail: window.firebaseUser
        }));
      } else if (!existingUID && !uidManager.authLocked) {
        console.log('No authentication found - initializing');
        uidManager.initializeAuthentication();
      }
    });

    // FIXED: Immediate initialization with enhanced persistence check
    (async function immediateInit() {
      try {
        // Wait for IndexedDB initialization
        await uidManager.initializeIndexedDB();
        
        const persistentUID = await uidManager.getUltraPersistentUID();

        if (persistentUID) {
          console.log('Immediate persistent UID restoration:', persistentUID.slice(0, 8) + '...');
          uidManager.persistentUID = persistentUID;
          window.firebaseUser = { uid: persistentUID };
          uidManager.isAuthInitialized = true;
          window.dispatchEvent(new CustomEvent('userAuthenticated', {
            detail: { uid: persistentUID }
          }));
        } else {
          // Only initialize Firebase auth if no persistent UID exists
          await uidManager.initializeAuthentication();
        }
      } catch (error) {
        console.error('Immediate initialization failed:', error);
        // Attempt recovery
        const recovered = await uidManager.recoverUID();
        if (!recovered) {
          await uidManager.initializeAuthentication();
        }
      }
    })();

    // Expose globals
    window.firebaseDB = db;
    window.firebaseAuth = auth;
    window.uidManager = uidManager;
    window.firebaseModules = {
      collection, doc, getDoc, setDoc, updateDoc, query, where, getDocs, deleteDoc, Timestamp, serverTimestamp, onSnapshot
    };

    // Signal that Firebase is ready
    window.firebaseReady = true;
    window.dispatchEvent(new Event('firebaseReady'));
  </script>

  <script src="https://js.puter.com/v2/"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" media="(prefers-color-scheme: dark)">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <style>
    :root {
      --primary-color: #6b46c1;
      --primary-dark: #553c9a;
      --background-gradient-start: #e9d5ff;
      --background-gradient-end: #c4b5fd;
      --chat-bg: rgba(255, 255, 255, 0.9);
      --chat-border: rgba(255, 255, 255, 0.2);
      --user-bg: linear-gradient(135deg, #7c3aed, #4c1d95);
      --ai-bg: linear-gradient(135deg, #e2e8f0, #cbd5e1);
      --text-color: #1f2937;
      --border-color: #d1d5db;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      --scrollbar-color: #6b46c1;
      --scrollbar-bg: #e5e7eb;
      --transition: all 0.3s ease;
      --blur: blur(8px);
      --gradient-colors: #ff6bcb, #6b46c1, #00c4ff, #ff6bcb;
      --code-bg: #f8f9fa;
      --code-border: #e9ecef;
      --topic-tag-bg: #e0e7ff;
      --topic-tag-text: #3730a3;
      --memory-bg: #f0f9ff;
      --memory-border: #0369a1;
      --related-topic-bg: #f3e8ff;
      --related-topic-text: #6d28d9;
      --toast-success: #10b981;
      --toast-error: #ef4444;
      --toast-warning: #f59e0b;
      --toast-info: #3b82f6;
      --image-preview-bg: #f3f4f6;
      --image-border: #9333ea;
      --photo-btn-bg: #7c3aed;
      --photo-btn-hover: #6d28d9;
      --key-panel-bg: #fef3c7;
      --key-panel-border: #f59e0b;
      --key-activated-bg: #d1fae5;
      --key-activated-border: #10b981;
      --key-expired-bg: #fee2e2;
      --key-expired-border: #ef4444;
      --key-deleted-bg: #1f2937;
      --key-deleted-border: #374151;
    }

    :root[data-theme="dark"] {
      --primary-color: #a78bfa;
      --primary-dark: #7c3aed;
      --background-gradient-start: #1e1b4b;
      --background-gradient-end: #2e1065;
      --chat-bg: rgba(30, 41, 59, 0.9);
      --chat-border: rgba(255, 255, 255, 0.1);
      --user-bg: linear-gradient(135deg, #a78bfa, #7c3aed);
      --ai-bg: linear-gradient(135deg, #475569, #334155);
      --text-color: #e2e8f0;
      --border-color: #475569;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      --scrollbar-color: #a78bfa;
      --scrollbar-bg: #1e293b;
      --gradient-colors: #ff6bcb, #a78bfa, #00c4ff, #ff6bcb;
      --code-bg: #1e293b;
      --code-border: #374151;
      --topic-tag-bg: #374151;
      --topic-tag-text: #a78bfa;
      --memory-bg: #1e293b;
      --memory-border: #0ea5e9;
      --related-topic-bg: #2e1065;
      --related-topic-text: #a78bfa;
      --image-preview-bg: #1f2937;
      --image-border: #a78bfa;
      --photo-btn-bg: #a78bfa;
      --photo-btn-hover: #9333ea;
      --key-panel-bg: #451a03;
      --key-panel-border: #f59e0b;
      --key-activated-bg: #064e3b;
      --key-activated-border: #10b981;
      --key-expired-bg: #450a0a;
      --key-expired-border: #ef4444;
      --key-deleted-bg: #111827;
      --key-deleted-border: #6b7280;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end));
      color: var(--text-color);
      min-height: 100vh;
      padding: 1rem;
      transition: var(--transition);
    }

    header {
      margin-bottom: 1rem;
      text-align: center;
      font-size: 1.125rem;
      font-weight: 500;
    }

    .app-container {
      width: 100%;
      max-width: min(90vw, 50rem);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Enhanced Key System Styles */
    .key-panel {
      background: var(--key-panel-bg);
      border: 2px solid var(--key-panel-border);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-bottom: 1rem;
      backdrop-filter: var(--blur);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }

    .key-panel.activated {
      background: var(--key-activated-bg);
      border-color: var(--key-activated-border);
    }

    .key-panel.expired {
      background: var(--key-expired-bg);
      border-color: var(--key-expired-border);
      animation: expiredPulse 2s infinite;
    }

    .key-panel.deleted {
      background: var(--key-deleted-bg);
      border-color: var(--key-deleted-border);
      opacity: 0.7;
    }

    @keyframes expiredPulse {
      0%, 100% { border-color: var(--key-expired-border); }
      50% { border-color: #fca5a5; }
    }

    .key-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
    }

    .key-status {
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .key-status .countdown {
      font-size: 0.875rem;
      font-weight: 500;
      margin-left: 0.5rem;
      padding: 0.25rem 0.5rem;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0.375rem;
    }

    .key-toggle-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      min-width: 80px;
    }

    .key-toggle-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    .key-details {
      display: none;
    }

    .key-details.show {
      display: block;
    }

    .key-input-group {
      display: flex;
      gap: 0.5rem;
      margin: 0.75rem 0;
    }

    .key-input {
      flex: 1;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      transition: var(--transition);
      text-transform: uppercase;
    }

    .key-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.75rem rgba(107, 70, 193, 0.4);
    }

    .key-input:disabled {
      background-color: #f3f4f6;
      color: #6b7280;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .key-submit-btn {
      background: var(--toast-success);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      white-space: nowrap;
    }

    .key-submit-btn:hover {
      background: #059669;
      transform: translateY(-0.125rem);
    }

    .key-submit-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    .key-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 0.75rem;
      margin: 0.75rem 0;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 0.5rem;
      backdrop-filter: blur(2px);
    }

    .key-info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.875rem;
      padding: 0.5rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 0.375rem;
    }

    .key-info-label {
      font-weight: 600;
      opacity: 0.8;
    }

    .key-info-value {
      font-weight: 500;
      text-align: right;
    }

    .key-countdown {
      font-size: 0.8125rem;
      padding: 0.375rem 0.75rem;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border-radius: 0.375rem;
      margin-top: 0.5rem;
      text-align: center;
      font-weight: 600;
      letter-spacing: 0.025em;
    }

    .key-countdown.warning {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      animation: warningPulse 1s infinite;
    }

    .key-countdown.critical {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      animation: criticalPulse 0.5s infinite;
    }

    @keyframes warningPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes criticalPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.02); }
    }

    .realtime-indicator {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      width: 8px;
      height: 8px;
      background: var(--toast-success);
      border-radius: 50%;
      animation: realtimePulse 2s infinite;
    }

    @keyframes realtimePulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .activation-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(16, 185, 129, 0.2);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .activation-animation.show {
      opacity: 1;
      pointer-events: auto;
    }

    .activation-content {
      background: var(--chat-bg);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      transform: scale(0.8);
      transition: transform 0.5s ease;
    }

    .activation-animation.show .activation-content {
      transform: scale(1);
    }

    .activation-checkmark {
      font-size: 4rem;
      color: var(--toast-success);
      margin-bottom: 1rem;
      animation: checkmarkPulse 1s ease-in-out;
    }

    @keyframes checkmarkPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .blocked-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    .blocked-message {
      background: var(--chat-bg);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      border: 2px solid var(--toast-error);
    }

    .blocked-message h3 {
      color: var(--toast-error);
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .blocked-message .pulsing-text {
      animation: textPulse 1.5s infinite;
    }

    @keyframes textPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Enhanced blocked buttons */
    .blocked-action-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      margin: 0.5rem;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      min-width: 120px;
    }

    .blocked-action-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    .blocked-action-btn.understand {
      background: var(--toast-info);
    }

    .blocked-action-btn.understand:hover {
      background: #2563eb;
    }

    .blocked-action-btn.contact {
      background: var(--toast-warning);
    }

    .blocked-action-btn.contact:hover {
      background: #d97706;
    }

    /* Contact Modal */
    .contact-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10001;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    .contact-modal-content {
      background: var(--chat-bg);
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      border: 2px solid var(--primary-color);
    }

    .contact-modal h3 {
      color: var(--primary-color);
      margin-bottom: 1.5rem;
      font-size: 1.25rem;
    }

    .contact-option {
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 1rem 1.5rem;
      margin: 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      min-width: 140px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .contact-option:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    .contact-option.whatsapp {
      background: #25d366;
    }

    .contact-option.whatsapp:hover {
      background: #1eb854;
    }

    .contact-option.gmail {
      background: #ea4335;
    }

    .contact-option.gmail:hover {
      background: #c5221f;
    }

    .contact-option.cancel {
      background: #6b7280;
    }

    .contact-option.cancel:hover {
      background: #4b5563;
    }

    .user-status {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0.5rem;
      padding: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .user-status.verified {
      background: rgba(16, 185, 129, 0.2);
      color: var(--toast-success);
    }

    .user-status.unverified {
      background: rgba(239, 68, 68, 0.2);
      color: var(--toast-error);
    }

    /* Enhanced performance-optimized controls */
    #controls-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    #model-selector-container, #conversation-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    #model-select, #conversation-select {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      cursor: pointer;
      transition: var(--transition);
      backdrop-filter: var(--blur);
      flex: 1;
      min-width: 120px;
    }

    #model-select:focus, #conversation-select:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.625rem rgba(107, 70, 193, 0.3);
    }

    .theme-toggle, .conversation-controls {
      display: flex;
      align-items: center;
      gap: 0.625rem;
    }

    .theme-toggle-label, .conversation-controls button {
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
    }

    .theme-toggle-switch {
      position: relative;
      width: 3.5rem;
      height: 1.75rem;
    }

    .theme-toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .theme-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border-color);
      border-radius: 1.75rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      padding: 0 0.25rem;
    }

    .theme-toggle-slider:before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='5'/%3E%3Cpath d='M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42'/%3E%3C/svg%3E");
      height: 1.5rem;
      width: 1.5rem;
      background-color: var(--chat-bg);
      border-radius: 50%;
      transition: var(--transition);
      transform: translateX(0);
    }

    .theme-toggle-switch input:checked + .theme-toggle-slider {
      background-color: var(--primary-color);
    }

    .theme-toggle-switch input:checked + .theme-toggle-slider:before {
      content: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z'/%3E%3C/svg%3E");
      transform: translateX(1.75rem);
    }

    .theme-toggle-switch input:focus + .theme-toggle-slider {
      box-shadow: 0 0 0.5rem var(--primary-color);
    }

    #new-conversation-btn, #delete-conversation-btn, #clear-memory-btn {
      padding: 0.625rem 1.25rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: var(--transition);
      min-width: 80px;
    }

    #new-conversation-btn:hover, #delete-conversation-btn:hover, #clear-memory-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    #delete-conversation-btn:disabled, #clear-memory-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    #clear-memory-btn {
      background: #dc2626;
    }

    #clear-memory-btn:hover:not(:disabled) {
      background: #b91c1c;
    }

    .memory-panel {
      background: var(--memory-bg);
      border: 1px solid var(--memory-border);
      border-radius: 0.75rem;
      padding: 1rem;
      margin-bottom: 1rem;
      max-height: 250px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg);
      backdrop-filter: var(--blur);
    }

    .memory-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--memory-border);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .topic-tag, .related-topic-tag {
      display: inline-block;
      background: var(--topic-tag-bg);
      color: var(--topic-tag-text);
      padding: 0.25rem 0.5rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      margin: 0.125rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .related-topic-tag {
      background: var(--related-topic-bg);
      color: var(--related-topic-text);
    }

    .topic-tag:hover, .related-topic-tag:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow);
    }

    .conversation-topic {
      background: var(--chat-bg);
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin: 0.5rem 0;
      backdrop-filter: var(--blur);
      cursor: pointer;
    }

    .conversation-title {
      font-weight: 600;
      color: var(--primary-color);
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
    }

    .conversation-summary {
      font-size: 0.8125rem;
      opacity: 0.8;
      line-height: 1.4;
    }

    .conversation-date {
      font-size: 0.75rem;
      opacity: 0.6;
      margin-top: 0.25rem;
    }

    .sync-status {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background: var(--chat-bg);
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      box-shadow: var(--shadow);
      display: none;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      z-index: 100;
      max-width: 300px;
    }

    .sync-status.show {
      display: flex;
    }

    .sync-spinner {
      width: 1rem;
      height: 1rem;
      border: 2px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Ultra-optimized chat container */
    #chat-container {
      width: 100%;
      min-height: 20rem;
      max-height: 60vh;
      border: 1px solid var(--chat-border);
      border-radius: 0.75rem;
      background-color: var(--chat-bg);
      backdrop-filter: var(--blur);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg);
      transition: var(--transition);
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      contain: layout;
    }

    /* High-performance scrollbar */
    #chat-container::-webkit-scrollbar {
      width: 6px;
    }

    #chat-container::-webkit-scrollbar-track {
      background: var(--scrollbar-bg);
      border-radius: 3px;
    }

    #chat-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-color);
      border-radius: 3px;
    }

    #chat-container::-webkit-scrollbar-thumb:hover {
      background: var(--primary-dark);
    }

    .message {
      margin: 0.75rem 0;
      padding: 0.75rem 1.125rem;
      border-radius: 0.75rem;
      max-width: 80%;
      word-wrap: break-word;
      animation: fadeIn 0.4s ease-in;
      position: relative;
      color: var(--text-color);
      transition: transform 0.2s ease;
      overflow: hidden;
      contain: layout style paint;
      will-change: transform, opacity;
    }

    .message:hover {
      transform: scale(1.02);
    }

    .message .timestamp {
      font-size: 0.75rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-top: 0.5rem;
      text-align: right;
    }

    .user {
      background: var(--user-bg);
      color: white;
      margin-left: auto;
      text-align: right;
      box-shadow: var(--shadow);
    }

    .ai {
      background: var(--ai-bg);
      margin-right: auto;
      text-align: left;
      box-shadow: var(--shadow);
      padding-right: 1.125rem;
    }

    .message-content {
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-width: 100%;
      position: relative;
      contain: layout style;
    }

    .message-content .copy-btn-inline {
      position: absolute;
      top: 0.25rem;
      right: 0.25rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.25rem;
      padding: 0.125rem 0.375rem;
      font-size: 0.625rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease, background-color 0.2s ease;
      z-index: 10;
    }

    .message-content:hover .copy-btn-inline {
      opacity: 0.8;
    }

    .message-content .copy-btn-inline:hover {
      opacity: 1;
      background-color: var(--primary-dark);
    }

    .code-block {
      position: relative;
      background-color: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      overflow: hidden;
      max-width: 100%;
      contain: layout style paint;
    }

    .code-block-header {
      background-color: var(--border-color);
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--code-border);
    }

    .code-block pre {
      margin: 0;
      padding: 1rem;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-width: 100%;
      overflow-x: auto;
    }

    .code-block code {
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.4;
    }

    .inline-code {
      background-color: var(--code-bg);
      border: 1px solid var(--code-border);
      border-radius: 0.25rem;
      padding: 0.125rem 0.375rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.875rem;
      position: relative;
      display: inline-block;
      cursor: pointer;
    }

    .inline-code .copy-btn-small {
      position: absolute;
      top: -0.5rem;
      right: -0.5rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 50%;
      width: 1.25rem;
      height: 1.25rem;
      font-size: 0.625rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .inline-code:hover .copy-btn-small {
      opacity: 1;
    }

    .copy-btn {
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s ease, background-color 0.2s ease;
    }

    .copy-btn:hover {
      opacity: 1;
      background-color: var(--primary-dark);
    }

    .copy-btn.copied {
      background-color: #48bb78;
    }

    .typing-indicator {
      background: var(--ai-bg);
      margin-right: auto;
      padding: 0.75rem 1.125rem;
      border-radius: 0.75rem;
      max-width: 80%;
      animation: fadeIn 0.4s ease-in;
      box-shadow: var(--shadow);
    }

    .typing-indicator::after {
      content: 'Analyzing...';
      animation: blink 1s infinite;
    }

    #input-container {
      width: 100%;
      display: flex;
      gap: 0.75rem;
      padding: 0.625rem;
      background: var(--chat-bg);
      border-radius: 0.75rem;
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      transition: var(--transition);
      flex-wrap: nowrap;
      align-items: center;
    }

    #user-input {
      flex-grow: 1;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      background-color: var(--chat-bg);
      color: var(--text-color);
      outline: none;
      transition: var(--transition);
      min-width: 0;
    }

    #user-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0.75rem rgba(107, 70, 193, 0.4);
      transform: translateY(-0.125rem);
    }

    .input-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    #photo-btn {
      position: relative;
      padding: 0.75rem;
      background: var(--photo-btn-bg);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 1.125rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
    }

    #photo-btn:hover {
      background: var(--photo-btn-hover);
      transform: translateY(-0.125rem);
    }

    #photo-btn input[type="file"] {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    #send-btn {
      padding: 0.75rem 1.5rem;
      background: var(--primary-color);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.9375rem;
      font-weight: 500;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      min-width: 80px;
    }

    #send-btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.4s ease, height 0.4s ease;
    }

    #send-btn:hover::after {
      width: 12.5rem;
      height: 12.5rem;
    }

    #send-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-0.125rem);
    }

    #send-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
      transform: none;
    }

    /* Image Preview */
    .image-preview-container {
      position: relative;
      margin: 0.5rem 0;
      padding: 0.75rem;
      background: var(--image-preview-bg);
      border: 2px dashed var(--image-border);
      border-radius: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .image-preview-wrapper {
      position: relative;
      display: inline-block;
    }

    .image-preview {
      max-width: 150px;
      max-height: 150px;
      border-radius: 0.5rem;
      object-fit: cover;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .image-preview:hover {
      transform: scale(1.05);
    }

    .remove-image {
      position: absolute;
      top: -8px;
      right: -8px;
      background: var(--toast-error);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease;
    }

    .remove-image:hover {
      transform: scale(1.1);
    }

    .message-image {
      max-width: 300px;
      max-height: 300px;
      border-radius: 0.5rem;
      margin: 0.5rem 0;
      cursor: pointer;
      transition: transform 0.2s ease;
      display: block;
    }

    .message-image:hover {
      transform: scale(1.02);
    }

    /* Image Modal */
    .image-modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.9);
      animation: fadeIn 0.3s ease;
    }

    .image-modal-content {
      margin: auto;
      display: block;
      max-width: 90%;
      max-height: 90%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: zoomIn 0.3s ease;
    }

    .close-modal {
      position: absolute;
      top: 15px;
      right: 35px;
      color: #f1f1f1;
      font-size: 40px;
      font-weight: bold;
      transition: 0.3s;
      cursor: pointer;
    }

    .close-modal:hover,
    .close-modal:focus {
      color: #bbb;
      text-decoration: none;
    }

    footer {
      margin-top: 1rem;
      text-align: center;
      font-size: 1.125rem;
      font-weight: 500;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .footer-links {
      display: flex;
      justify-content: center;
      gap: 2rem;
    }

    .powered-by, .contact-link, .key-link {
      display: inline-block;
      background: linear-gradient(90deg, var(--gradient-colors));
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: gradientShift 5s linear infinite;
      transition: transform 0.2s ease;
      text-decoration: none;
      font-weight: 600;
    }

    .contact-link:hover, .key-link:hover {
      transform: scale(1.05);
    }

    /* Toast System */
    .toast-container {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      pointer-events: none;
    }

    .toast {
      background: white;
      border-radius: 0.5rem;
      padding: 1rem 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      min-width: 300px;
      max-width: 400px;
      transform: translateX(100%);
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: auto;
      border-left: 4px solid;
    }

    .toast.show {
      transform: translateX(0);
    }

    .toast.success {
      border-left-color: var(--toast-success);
      background: #f0fdf4;
      color: #166534;
    }

    .toast.error {
      border-left-color: var(--toast-error);
      background: #fef2f2;
      color: #991b1b;
    }

    .toast.warning {
      border-left-color: var(--toast-warning);
      background: #fefdf8;
      color: #92400e;
    }

    .toast.info {
      border-left-color: var(--toast-info);
      background: #eff6ff;
      color: #1e40af;
    }

    .toast-icon {
      font-size: 1.25rem;
      flex-shrink: 0;
    }

    .toast-content {
      flex: 1;
    }

    .toast-title {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .toast-message {
      font-size: 0.875rem;
      opacity: 0.8;
    }

    .toast-close {
      background: none;
      border: none;
      font-size: 1.125rem;
      cursor: pointer;
      padding: 0;
      width: 1.5rem;
      height: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    .toast-close:hover {
      opacity: 1;
    }

    .connection-status {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      background: var(--chat-bg);
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      box-shadow: var(--shadow);
      backdrop-filter: var(--blur);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      z-index: 100;
    }

    .connection-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--toast-error);
    }

    .connection-indicator.connected {
      background: var(--toast-success);
    }

    @keyframes gradientShift {
      0% { background-position: 200% 0; }
      100% { background-position: 0 0; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(0.625rem); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes zoomIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes blink {
      50% { opacity: 0.5; }
    }

    @media (max-width: 600px) {
      body {
        padding: 0.5rem;
      }
      .app-container {
        max-width: 95vw;
      }
      #model-selector-container, #conversation-controls {
        flex-direction: column;
        align-items: stretch;
      }
      #model-select, #conversation-select, #new-conversation-btn, #delete-conversation-btn, #clear-memory-btn {
        width: 100%;
      }
      #chat-container {
        min-height: 15rem;
        max-height: 50vh;
        padding: 0.75rem;
      }
      .message {
        max-width: 90%;
        padding: 0.625rem 0.875rem;
      }
      #input-container {
        padding: 0.5rem;
        gap: 0.5rem;
      }
      #user-input {
        font-size: 0.875rem;
        padding: 0.625rem;
      }
      #send-btn {
        font-size: 0.875rem;
        padding: 0.625rem 1rem;
        min-width: 70px;
      }
      #photo-btn {
        width: 44px;
        height: 44px;
        font-size: 1rem;
      }
      .image-preview {
        max-width: 100px;
        max-height: 100px;
      }
      .message-image {
        max-width: 200px;
        max-height: 200px;
      }
      header, footer {
        font-size: 0.875rem;
      }
      .footer-links {
        flex-direction: column;
        gap: 0.5rem;
      }
      .memory-panel {
        max-height: 200px;
        padding: 0.75rem;
      }
      .toast-container {
        top: 0.5rem;
        right: 0.5rem;
        left: 0.5rem;
      }
      .toast {
        min-width: auto;
        max-width: none;
      }
      .typing-indicator::after {
        font-size: 0.875rem;
      }
      .connection-status {
        bottom: 0.5rem;
        left: 0.5rem;
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
      }
      .key-input-group {
        flex-direction: column;
        gap: 0.5rem;
      }
      .key-submit-btn {
        padding: 0.75rem;
      }
      .key-info {
        grid-template-columns: 1fr;
      }
      .blocked-message {
        max-width: 90%;
        padding: 1.5rem;
      }
      .contact-modal-content {
        max-width: 90%;
        padding: 1.5rem;
      }
      .contact-option, .blocked-action-btn {
        min-width: 100px;
        padding: 0.75rem 1rem;
        margin: 0.25rem;
        font-size: 0.875rem;
      }
    }

    @media (max-width: 400px) {
      #input-container {
        flex-wrap: wrap;
      }
      .input-actions {
        width: 100%;
        justify-content: space-between;
      }
      #user-input {
        width: 100%;
      }
      #send-btn {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div class="toast-container" id="toast-container"></div>

  <!-- Activation Animation -->
  <div class="activation-animation" id="activation-animation">
    <div class="activation-content">
      <div class="activation-checkmark">✓</div>
      <h3>Key Activated Successfully!</h3>
      <p>User authenticated for AI access...</p>
    </div>
  </div>

  <div class="sync-status" id="sync-status">
    <div class="sync-spinner"></div>
    <span id="sync-message">Connecting to GoFile cloud...</span>
  </div>

  <div class="connection-status" id="connection-status">
    <div class="connection-indicator" id="connection-indicator"></div>
    <span id="connection-text">Connecting...</span>
  </div>

  <!-- Image Modal -->
  <div id="imageModal" class="image-modal">
    <span class="close-modal" onclick="closeImageModal()">&times;</span>
    <img class="image-modal-content" id="modalImage">
  </div>

  <header>
    <span class="powered-by">AI CHATBOT WITH PHOTO ANALYSIS & ADVANCED MEMORY - POWERED BY BARNI</span>
  </header>

  <div class="app-container">
    <!-- FIXED: Firebase UID-Based Key Activation Panel -->
    <div class="key-panel" id="key-panel">
      <div class="realtime-indicator" id="realtime-indicator"></div>
      <div class="key-header">
        <div class="key-status" id="key-status">
          🔐 Key Status: Checking authentication...
          <span class="countdown" id="key-countdown" style="display: none;"></span>
        </div>
        <button class="key-toggle-btn" id="key-toggle-btn" onclick="toggleKeyPanel()">
          Activate
        </button>
      </div>
      
      <div class="user-status" id="user-status">
        <span>🔍 Authenticating with Firebase...</span>
      </div>
      
      <div class="key-details" id="key-details">
        <div class="key-input-group">
          <input type="text" class="key-input" id="key-input" placeholder="Enter your activation key..." maxlength="20">
          <button class="key-submit-btn" id="key-submit-btn" onclick="activateKey()">
            Activate
          </button>
        </div>
        <div id="key-info" class="key-info"></div>
        <div id="key-countdown-display" class="key-countdown" style="display: none;"></div>
      </div>
    </div>

    <div class="memory-panel" id="memory-panel" style="display: none;">
      <div class="memory-title">
        🧠 Advanced Memory Bank (GoFile Cloud)
        <button id="clear-memory-btn" style="margin-left: auto; padding: 0.25rem 0.5rem; font-size: 0.75rem;">Clear Memory</button>
      </div>
      <div id="memory-content"></div>
    </div>

    <div id="controls-container">
      <div id="model-selector-container">
        <label for="model-select" class="theme-toggle-label">Choose AI Model:</label>
        <select id="model-select" aria-label="Select AI model"></select>
        <div class="theme-toggle">
          <label for="theme-toggle" class="theme-toggle-label">Toggle Theme</label>
          <div class="theme-toggle-switch">
            <input type="checkbox" id="theme-toggle" aria-label="Toggle between light and dark theme">
            <span class="theme-toggle-slider"></span>
          </div>
        </div>
      </div>
      <div id="conversation-controls">
        <label for="conversation-select" class="theme-toggle-label">Conversation:</label>
        <select id="conversation-select" aria-label="Select conversation"></select>
        <div class="conversation-controls">
          <button id="new-conversation-btn" aria-label="Start new conversation">New</button>
          <button id="delete-conversation-btn" aria-label="Delete current conversation">Delete</button>
        </div>
      </div>
    </div>

    <!-- Image Preview Container -->
    <div id="image-preview-container" class="image-preview-container" style="display: none;">
      <div id="image-previews"></div>
    </div>

    <div id="chat-container"></div>

    <div id="input-container">
      <input type="text" id="user-input" placeholder="Type your message..." autocomplete="off" aria-label="Type your message">
      <div class="input-actions">
        <button id="photo-btn" aria-label="Attach photo">
          📷
          <input type="file" id="file-input" accept="image/*" multiple>
        </button>
        <button id="send-btn" aria-label="Send message">Send</button>
      </div>
    </div>
  </div>

  <footer>
    <div class="footer-links">
      <a href="mailto:barnigonzales43329@gmail.com" class="contact-link" aria-label="Contact via email">CONTACT</a>
      <a href="#" class="key-link" id="key-link" onclick="toggleKeyPanel()">KEY</a>
    </div>
  </footer>

  <script>
    // Enhanced Firebase readiness detection with performance optimization
    function waitForFirebase() {
      return new Promise((resolve) => {
        if (window.firebaseReady && window.uidManager) {
          resolve();
        } else {
          const handler = () => {
            if (window.firebaseReady && window.uidManager) {
              window.removeEventListener('firebaseReady', handler);
              resolve();
            }
          };
          window.addEventListener('firebaseReady', handler);
          
          // Fail-safe timeout
          setTimeout(() => {
            window.removeEventListener('firebaseReady', handler);
            resolve();
          }, 5000);
        }
      });
    }

    async function initializeApp() {
      // Wait for Firebase with enhanced stability
      await waitForFirebase();
      
      // Additional stabilization period for auth
      await new Promise(resolve => setTimeout(resolve, 300));

      // FIXED: Ultra-Optimized Firebase UID-Based Key System with TRUE Perpetual Persistence
      class UltraPersistentKeySystem {
        constructor() {
          this.isActivated = false; 
          this.isBlocked = false;
          this.keyData = null;
          this.userUID = null;
          this.baseUrl = 'https://barnigonz.github.io/Aib4n1x/';
          this.realtimeListener = null;
          this.countdownInterval = null;
          this.blockedOverlay = null;
          this.authChecked = false;
          this.initializationComplete = false;
          this.systemReady = false;
          this.retryAttempts = 0;
          this.maxRetryAttempts = 5;
          this.retryDelay = 1000;
          this.performanceMonitor = new Map();
          
          // FIXED: Enhanced storage keys with ultra-persistence versioning
          this.storageKeys = {
            activation: 'ai_chatbot_ultra_persistent_uid_v7_PERMANENT',
            keyData: 'ai_chatbot_key_data_ultra_uid_v7_PERMANENT', 
            keyId: 'ai_chatbot_key_id_ultra_uid_v7_PERMANENT',
            activationTime: 'ai_chatbot_activation_time_ultra_uid_v7_PERMANENT',
            userUID: 'ai_chatbot_user_uid_persistent_v7_PERMANENT',
            lastValidation: 'ai_chatbot_last_validation_ultra_v7_PERMANENT'
          };
          
          this.initWithPerformanceTracking();
        }

        async initWithPerformanceTracking() {
          const startTime = performance.now();
          
          try {
            await this.waitForAuthWithEnhancedRetry();
            this.updateUserStatus();
            this.authChecked = true;
            
            // FIXED: Check for perpetual activation first with enhanced persistence
            const hasPersistentActivation = await this.checkPerpetuallyStoredActivation();
            
            if (!hasPersistentActivation) {
              await this.checkUrlAndStorageKeys();
            }
            
            this.updateUI();
            this.startOptimizedCountdown();
            this.initializationComplete = true;
            this.systemReady = true;
            
            const endTime = performance.now();
            this.performanceMonitor.set('initialization', endTime - startTime);
            console.log(`FIXED Key system initialized in ${(endTime - startTime).toFixed(2)}ms`);
            
          } catch (error) {
            console.error('Ultra-persistent key system initialization error:', error);
            this.systemReady = true;
            this.initializationComplete = true;
          }
        }

        // FIXED: Enhanced auth waiting with UID manager integration
        async waitForAuthWithEnhancedRetry() {
          return new Promise((resolve) => {
            const checkAuth = async () => {
              try {
                // FIXED: Use the enhanced ultra-persistent UID manager
                const currentUID = window.uidManager?.getCurrentUID();
                
                if (currentUID) {
                  this.userUID = currentUID;
                  await this.persistUserUID();
                  console.log('FIXED: Ultra-persistent UID acquired:', this.userUID.slice(0, 8) + '...');
                  resolve();
                  return;
                }

                // FIXED: Try to recover from persistent storage with enhanced methods
                const storedUID = await this.getStoredUserUID();
                if (storedUID) {
                  this.userUID = storedUID;
                  console.log('FIXED: Restored UID from enhanced persistent storage:', this.userUID.slice(0, 8) + '...');
                  resolve();
                  return;
                }

                if (this.retryAttempts < this.maxRetryAttempts) {
                  this.retryAttempts++;
                  console.log(`FIXED: Retry attempt ${this.retryAttempts}/${this.maxRetryAttempts}`);
                  setTimeout(checkAuth, this.retryDelay * this.retryAttempts);
                } else {
                  console.warn('FIXED: Max retry attempts reached, resolving without UID');
                  resolve();
                }
              } catch (error) {
                console.error('Auth check error:', error);
                if (this.retryAttempts < this.maxRetryAttempts) {
                  this.retryAttempts++;
                  setTimeout(checkAuth, this.retryDelay * this.retryAttempts);
                } else {
                  resolve();
                }
              }
            };
            
            // FIXED: Listen for auth changes with enhanced persistence check
            if (window.uidManager) {
              window.addEventListener('userAuthenticated', async (event) => {
                if (event.detail?.uid) {
                  this.userUID = event.detail.uid;
                  await this.persistUserUID();
                  console.log('FIXED: UID authenticated via event:', this.userUID.slice(0, 8) + '...');
                  resolve();
                }
              }, { once: true });
            }
            
            checkAuth();
          });
        }

        // FIXED: Enhanced UID persistence with IndexedDB integration 
        async persistUserUID() {
          try {
            const uidData = {
              uid: this.userUID,
              timestamp: Date.now(),
              version: 'v7',
              ultrapersistent: true,
              permanentActivation: true,
              deviceBound: true
            };
            
            // FIXED: Multiple storage layers for ultimate persistence
            const serialized = JSON.stringify(uidData);
            
            // Layer 1: IndexedDB (if available)
            if (window.uidManager?.indexedDBReady) {
              try {
                await this.storeInIndexedDB('userUID', uidData);
              } catch (e) {
                console.warn('IndexedDB UID storage failed:', e);
              }
            }
            
            // Layer 2-6: Multiple localStorage/sessionStorage layers
            const storageKeys = [
              this.storageKeys.userUID,
              this.storageKeys.userUID + '_backup',
              this.storageKeys.userUID + '_emergency',
              this.storageKeys.userUID + '_recovery'
            ];
            
            storageKeys.forEach(key => {
              try {
                localStorage.setItem(key, serialized);
                sessionStorage.setItem(key + '_session', serialized);
              } catch (e) {
                console.warn(`Storage failed for key ${key}:`, e);
              }
            });
            
            console.log('FIXED: UID stored with enhanced ultra-persistence');
          } catch (e) {
            console.warn('FIXED: Failed to persist UID:', e);
          }
        }

        // FIXED: Enhanced UID retrieval with all storage layers
        async getStoredUserUID() {
          const sources = [
            // IndexedDB first (highest persistence)
            () => this.getFromIndexedDB('userUID'),
            
            // Session storage (current session)
            () => this.getFromStorage(sessionStorage, this.storageKeys.userUID + '_session'),
            
            // Local storage layers
            () => this.getFromStorage(localStorage, this.storageKeys.userUID),
            () => this.getFromStorage(localStorage, this.storageKeys.userUID + '_backup'),
            () => this.getFromStorage(localStorage, this.storageKeys.userUID + '_emergency'),
            () => this.getFromStorage(localStorage, this.storageKeys.userUID + '_recovery')
          ];
          
          for (const getSource of sources) {
            try {
              const uid = await getSource();
              if (uid && typeof uid === 'string' && uid.length > 10) {
                console.log('FIXED: UID recovered from storage source');
                return uid;
              }
            } catch (e) {
              continue;
            }
          }
          
          return null;
        }

        // FIXED: IndexedDB storage helper
        async storeInIndexedDB(key, data) {
          if (!window.uidManager?.indexedDB) return;
          
          return new Promise((resolve, reject) => {
            try {
              const transaction = window.uidManager.indexedDB.transaction(['uids'], 'readwrite');
              const store = transaction.objectStore('uids');
              const request = store.put({ id: key, ...data });
              
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            } catch (e) {
              reject(e);
            }
          });
        }

        // FIXED: IndexedDB retrieval helper
        async getFromIndexedDB(key) {
          if (!window.uidManager?.indexedDB) return null;
          
          return new Promise((resolve) => {
            try {
              const transaction = window.uidManager.indexedDB.transaction(['uids'], 'readonly');
              const store = transaction.objectStore('uids');
              const request = store.get(key);
              
              request.onsuccess = () => {
                const result = request.result;
                if (result && result.uid && result.ultrapersistent) {
                  resolve(result.uid);
                } else {
                  resolve(null);
                }
              };
              
              request.onerror = () => resolve(null);
            } catch (e) {
              resolve(null);
            }
          });
        }

        // FIXED: Storage retrieval helper
        getFromStorage(storage, key) {
          try {
            const data = storage.getItem(key);
            if (data) {
              const parsed = JSON.parse(data);
              if (parsed.uid && parsed.ultrapersistent && parsed.version === 'v7') {
                return parsed.uid;
              }
            }
          } catch (e) {
            // Continue to next source
          }
          return null;
        }

        updateUserStatus() {
          const userStatus = document.getElementById('user-status');
          if (this.userUID) {
            const shortUID = this.userUID.slice(0, 8) + '...';
            userStatus.className = 'user-status verified';
            userStatus.innerHTML = `<span>✅ Ultra-Persistent UID: ${shortUID} (PERMANENT - Never Resets)</span>`;
          } else {
            userStatus.className = 'user-status unverified';
            userStatus.innerHTML = `<span>❌ Authentication pending...</span>`;
          }
        }

        // FIXED: Ultra-persistent storage with enhanced redundancy
        setUltraPersistentStorage(key, value) {
          const data = {
            value: value,
            timestamp: Date.now(),
            uid: this.userUID,
            version: 'v7',
            ultrapersistent: true,
            permanentActivation: true,
            deviceBound: true
          };
          
          const serialized = JSON.stringify(data);
          
          // FIXED: Enhanced redundancy - 10+ storage layers
          const storageOperations = [
            // Primary localStorage
            () => localStorage.setItem(key, serialized),
            () => localStorage.setItem(key + '_primary', serialized),
            () => localStorage.setItem(key + '_backup', serialized),
            () => localStorage.setItem(key + '_emergency', serialized),
            () => localStorage.setItem(key + '_recovery', serialized),
            
            // SessionStorage layers
            () => sessionStorage.setItem(key, serialized),
            () => sessionStorage.setItem(key + '_session', serialized),
            () => sessionStorage.setItem(key + '_session_backup', serialized),
            
            // IndexedDB if available
            () => this.storeInIndexedDB(key.replace(/[^a-zA-Z0-9]/g, '_'), data)
          ];
          
          let successCount = 0;
          storageOperations.forEach(operation => {
            try {
              operation();
              successCount++;
            } catch (e) {
              console.warn('Storage operation failed:', e);
            }
          });
          
          console.log(`FIXED: Data stored in ${successCount}/${storageOperations.length} storage layers`);
          
          // Memory fallback
          if (successCount === 0) {
            this.memoryFallback = this.memoryFallback || new Map();
            this.memoryFallback.set(key, data);
            console.log('FIXED: Using memory fallback storage');
          }
        }

        // FIXED: Enhanced retrieval with all storage layers
        getUltraPersistentStorage(key) {
          const sources = [
            // IndexedDB first
            () => this.getFromIndexedDB(key.replace(/[^a-zA-Z0-9]/g, '_')),
            
            // Session storage
            () => sessionStorage.getItem(key),
            () => sessionStorage.getItem(key + '_session'),
            () => sessionStorage.getItem(key + '_session_backup'),
            
            // Local storage layers
            () => localStorage.getItem(key),
            () => localStorage.getItem(key + '_primary'),
            () => localStorage.getItem(key + '_backup'),
            () => localStorage.getItem(key + '_emergency'),
            () => localStorage.getItem(key + '_recovery'),
            
            // Memory fallback
            () => this.memoryFallback?.get(key)
          ];
          
          for (const getSource of sources) {
            try {
              const item = getSource();
              if (item) {
                let data;
                if (typeof item === 'string') {
                  data = JSON.parse(item);
                } else if (typeof item === 'object') {
                  data = item;
                } else {
                  continue;
                }
                
                if (data?.uid === this.userUID &&
                    data?.ultrapersistent &&
                    data?.version === 'v7' &&
                    data?.value !== undefined) {
                  return data.value;
                }
              }
            } catch (e) {
              continue;
            }
          }
          return null;
        }

        // FIXED: Enhanced removal across all storage layers
        removeUltraPersistentStorage(key) {
          const keys = [key, key + '_primary', key + '_backup', key + '_emergency', key + '_recovery', key + '_session', key + '_session_backup'];
          
          keys.forEach(k => {
            try {
              localStorage.removeItem(k);
              sessionStorage.removeItem(k);
            } catch (e) {
              console.warn('Failed to remove storage key:', k, e);
            }
          });
          
          // Remove from IndexedDB
          if (window.uidManager?.indexedDB) {
            try {
              const transaction = window.uidManager.indexedDB.transaction(['uids'], 'readwrite');
              const store = transaction.objectStore('uids');
              store.delete(key.replace(/[^a-zA-Z0-9]/g, '_'));
            } catch (e) {
              console.warn('Failed to remove from IndexedDB:', e);
            }
          }
          
          if (this.memoryFallback) {
            this.memoryFallback.delete(key);
          }
        }

        // FIXED: Enhanced perpetual activation checker that preserves stored keys
        async checkPerpetuallyStoredActivation() {
          try {
            console.log('FIXED: Checking for perpetual activation...');
            
            const persistedActivation = this.getUltraPersistentStorage(this.storageKeys.activation);
            const persistedKeyData = this.getUltraPersistentStorage(this.storageKeys.keyData);
            const persistedKeyId = this.getUltraPersistentStorage(this.storageKeys.keyId);
            
            console.log('FIXED: Perpetual activation check:', {
              activation: persistedActivation,
              hasKeyData: !!persistedKeyData,
              keyId: persistedKeyId,
              uid: this.userUID?.slice(0, 8) + '...'
            });
            
            // FIXED: If we have a stored activation, validate it WITHOUT clearing it
            if (persistedActivation && persistedKeyData && persistedKeyId && this.userUID) {
              console.log('FIXED: Found perpetual activation for UID:', this.userUID.slice(0, 8) + '...');
              
              try {
                // FIXED: Restore the activation state first
                this.keyData = JSON.parse(persistedKeyData);
                this.isActivated = true;
                
                // FIXED: Now validate it, but don't clear on failure
                await this.validateStoredKey(persistedKeyId, true);
                console.log('FIXED: Successfully restored perpetual activation');
                this.queueToast('success', 'Welcome Back!', 'Your ultra-persistent activation is active and will never reset.');
                return true;
              } catch (error) {
                console.log('FIXED: Perpetual key validation failed:', error.message);
                
                // FIXED: Handle deletion/expiration with detailed messaging
                if (error.message.includes('deleted')) {
                  const expiryDate = this.keyData?.expiresAt ? this.parseKeyDate(this.keyData.expiresAt) : null;
                  this.blockUser('Key Deleted', 
                    'Your activation key has been permanently deleted by admin.',
                    expiryDate ? `The key expired on ${expiryDate.toLocaleDateString()} at ${expiryDate.toLocaleTimeString()}` : null
                  );
                  return false;
                 } else if (error.message.includes('expired')) {
                  const match = error.message.match(/expired on (.+)/);
                  const expiryText = match ? match[1] : 'recently';
                  this.blockUser('Key Expired', 
                    `Your activation key expired on ${expiryText}. Please contact support to renew your access.`,
                    `Expiry details: ${error.message}`
                  );
                  return false;
                } else {
                  // For other errors (network, etc), keep the activation and retry later
                  console.log('FIXED: Non-critical validation error, maintaining activation for retry');
                  this.queueToast('warning', 'Validation Warning', 'Activation restored but validation had issues. Will retry automatically.');
                  return true;
                }
              }
            } else {
              console.log('FIXED: No perpetual activation found in any storage layer');
            }
          } catch (error) {
            console.error('FIXED: Error checking perpetual activation:', error);
          }
          return false;
        }

        // FIXED: Clear activation but maintain storage structure for re-activation
        clearPerpetuallySavedActivation() {
          console.log('FIXED: Clearing perpetual activation for re-activation');
          this.removeUltraPersistentStorage(this.storageKeys.activation);
          this.removeUltraPersistentStorage(this.storageKeys.keyData);
          this.removeUltraPersistentStorage(this.storageKeys.keyId);
          this.removeUltraPersistentStorage(this.storageKeys.activationTime);
          this.removeUltraPersistentStorage(this.storageKeys.lastValidation);
          this.isActivated = false;
          this.keyData = null;
        }

        // FIXED: Enhanced URL and storage key checking
        async checkUrlAndStorageKeys() {
          // Check URL first
          const urlKey = this.extractKeyFromUrl();
          if (urlKey) {
            console.log('FIXED: Found URL key:', urlKey);
            try {
              await this.validateStoredKey(urlKey.toUpperCase());
              return;
            } catch (error) {
              console.error('FIXED: URL key validation failed:', error);
              if (this.systemReady && (error.message.includes('does not exist') ||
                                     error.message.includes('expired') ||
                                     error.message.includes('used'))) {
                this.queueToast('error', 'Invalid URL Key', 'The key in the URL is invalid or expired.');
              }
            }
          }

          // Check if we have any stored keys that might need validation
          const storedKeyId = this.getUltraPersistentStorage(this.storageKeys.keyId);
          if (storedKeyId && !this.isActivated) {
            console.log('FIXED: Found stored key ID, attempting recovery:', storedKeyId);
            try {
              await this.validateStoredKey(storedKeyId, true);
            } catch (error) {
              console.log('FIXED: Stored key recovery failed:', error.message);
              // Don't clear here, let user manually re-activate if needed
            }
          }
        }

        // FIXED: Extract key from URL with better pattern matching
        extractKeyFromUrl() {
          const path = window.location.pathname;
          const pathParts = path.split('/').filter(p => p);
          
          let potentialKey = null;
          
          // Handle both patterns: /Aib4n1x/KEY and /KEY
          if (pathParts.length >= 2 && pathParts[pathParts.length - 2] === 'Aib4n1x') {
            potentialKey = pathParts[pathParts.length - 1];
          } else if (pathParts.length === 1) {
            potentialKey = pathParts[0];
          }
          
          // Validate key format
          if (potentialKey &&
              !potentialKey.includes('.') &&
              potentialKey.length >= 6 &&
              potentialKey.length <= 16 &&
              /^[A-Z0-9]+$/i.test(potentialKey)) {
            return potentialKey;
          }
          
          return null;
        }

        parseKeyDate(dateValue) {
          if (!dateValue) return null;
          
          if (dateValue && typeof dateValue.toDate === 'function') {
            return dateValue.toDate();
          }
          
          if (typeof dateValue === 'string') {
            return new Date(dateValue);
          }
          
          if (dateValue instanceof Date) {
            return dateValue;
          }
          
          if (dateValue && typeof dateValue === 'object' && dateValue.seconds) {
            return new Date(dateValue.seconds * 1000);
          }
          
          return null;
        }

        // FIXED: Instant real-time monitoring with zero-latency blocking
        startUltraFastRealtimeMonitoring(keyId) {
          if (this.realtimeListener) {
            this.realtimeListener();
          }
          
          if (!keyId || !window.firebaseDB || !window.firebaseModules) {
            console.warn('FIXED: Cannot start monitoring - missing dependencies');
            return;
          }
          
          const { doc, onSnapshot } = window.firebaseModules;
          
          console.log('FIXED: Starting ultra-fast realtime monitoring for key:', keyId);
          
          this.realtimeListener = onSnapshot(
            doc(window.firebaseDB, 'activation_keys', keyId),
            (docSnapshot) => {
              const startTime = performance.now();
              
              // FIXED: Instant deletion detection without delay
              if (!docSnapshot.exists()) {
                console.log('FIXED: Key deleted - INSTANT blocking response');
                this.handleKeyDeletedInstantly();
                return;
              }
              
              const newKeyData = docSnapshot.data();
              console.log('FIXED: Key updated in realtime:', newKeyData);
              
              // FIXED: Instant status change processing
               this.checkKeyStatusChangeInstantly(newKeyData);
              
              const endTime = performance.now();
              this.performanceMonitor.set('realtimeUpdate', endTime - startTime);
              console.log(`FIXED: Realtime update processed in ${(endTime - startTime).toFixed(2)}ms`);
            },
            (error) => {
              console.error('FIXED: Realtime monitoring error:', error);
              this.queueToast('warning', 'Monitoring Interrupted', 'Real-time key monitoring temporarily interrupted. Auto-restoring...');
              
              // FIXED: Enhanced auto-retry with exponential backoff
              setTimeout(() => {
                console.log('FIXED: Attempting to restore realtime monitoring...');
                this.startUltraFastRealtimeMonitoring(keyId);
              }, 2000);
            }
          );
        }

        // FIXED: Instant status change detection with zero delay
        checkKeyStatusChangeInstantly(newKeyData) {
          const wasActivated = this.isActivated;
          const oldExpiryDate = this.keyData?.expiresAt ? this.parseKeyDate(this.keyData.expiresAt) : null;
          const newExpiryDate = newKeyData.expiresAt ? this.parseKeyDate(newKeyData.expiresAt) : null;
          
          // FIXED: Update key data with zero latency
          this.keyData = { ...newKeyData, id: this.keyData?.id };
          
          // FIXED: Update persistent data instantly to maintain ultra-persistent activation
          if (this.isActivated) {
            this.setUltraPersistentStorage(this.storageKeys.keyData, JSON.stringify(this.keyData));
          }
          
          // FIXED: Zero-lag expiry check - block immediately on expiry
          if (newExpiryDate && new Date() > newExpiryDate) {
            if (wasActivated) {
              console.log('FIXED: Key expired - INSTANT blocking');
              this.handleKeyExpiredInstantly();
            }
            return;
          }
          
          // FIXED: Instant notification for key extension
          if (oldExpiryDate && newExpiryDate && newExpiryDate > oldExpiryDate) {
            this.queueToast('success', 'Key Extended', 'Your activation key time has been extended!');
          }
          
          this.updateUI();
        }

        // FIXED: Enhanced key deletion handler with specific toast and overlay
        handleKeyDeletedInstantly() {
          console.log('FIXED: Key deleted by admin - INSTANT blocking without delay');
          
          // FIXED: Show specific deletion toast
          this.queueToast('error', 'KEY DELETED', 'Your key has been deleted by admin');
          
          // FIXED: Immediate state change
          this.isActivated = false;
          this.keyData = null;
          
          // FIXED: Clear activation but keep UID persistent
          this.clearPerpetuallySavedActivation();
          
          // FIXED: Show specific deletion overlay
          this.blockUser('Key Deleted', 'Your activation key has been permanently deleted by admin.');
          this.updateUI();
        }

        // FIXED: Enhanced key expiration handler with specific messaging
        handleKeyExpiredInstantly() {
          console.log('FIXED: Key expired - INSTANT blocking without delay');
          
          const expiryDate = this.keyData?.expiresAt ? this.parseKeyDate(this.keyData.expiresAt) : null;
          const expiryText = expiryDate ? 
            `${expiryDate.toLocaleDateString()} at ${expiryDate.toLocaleTimeString()}` : 
            'recently';
          
          // FIXED: Show specific expiration toast with exact details
          this.queueToast('error', 'KEY EXPIRED', 
            `Your key expired on ${expiryText}. Please contact support for renewal.`);
          
          // FIXED: Immediate state change 
          this.isActivated = false;
          
          // FIXED: Clear activation but keep UID for potential renewal
          this.clearPerpetuallySavedActivation();
          
          // FIXED: Show specific expiration overlay with details
          this.blockUser('Key Expired', 
            `Your activation key expired on ${expiryText}. Please contact support to renew your access.`,
            expiryDate ? `Exact expiry: ${expiryDate.toLocaleString()}` : null);
          this.updateUI();
        }

        // FIXED: Enhanced blocking with new UI structure
        blockUser(title, message, details = null) {
          this.isBlocked = true;
          this.showBlockedOverlay(title, message, details);
          this.blockAIFunctionality();
          
          // FIXED: Immediately disable all input controls
          const userInput = document.getElementById('user-input');
          const sendBtn = document.getElementById('send-btn');
          const photoBtn = document.getElementById('photo-btn');
          
          if (userInput) {
            userInput.disabled = true;
            userInput.placeholder = 'AI access blocked - activation required';
          }
          if (sendBtn) {
            sendBtn.disabled = true;
          }
          if (photoBtn) {
            photoBtn.disabled = true;
          }
        }

        // FIXED: Enhanced blocked overlay with new structure per requirements
        showBlockedOverlay(title, message, details = null) {
          if (this.blockedOverlay) {
            this.blockedOverlay.remove();
          }
          
          this.blockedOverlay = document.createElement('div');
          this.blockedOverlay.className = 'blocked-overlay';
          this.blockedOverlay.innerHTML = `
            <div class="blocked-message">
              <h3>${title}</h3>
              <p class="pulsing-text">${message}</p>
              ${details ? `<p style="margin-top: 0.5rem; font-size: 0.875rem; opacity: 0.8;">${details}</p>` : ''}
              <div style="margin-top: 1.5rem;">
                <button class="blocked-action-btn understand" onclick="handleUnderstandAction()">
                  I understand
                </button>
                <button class="blocked-action-btn contact" onclick="showContactModal()">
                  CONTACT FOR KEY
                </button>
              </div>
            </div>
          `;
          
          document.body.appendChild(this.blockedOverlay);
        }

        // FIXED: Enhanced unblocking when key is restored
        hideBlockedOverlay() {
          if (this.blockedOverlay) {
            this.blockedOverlay.remove();
            this.blockedOverlay = null;
          }
          this.isBlocked = false;
          
          // FIXED: Re-enable controls
          const userInput = document.getElementById('user-input');
          const sendBtn = document.getElementById('send-btn');
          const photoBtn = document.getElementById('photo-btn');
          
          if (userInput) {
            userInput.disabled = false;
            userInput.placeholder = 'Type your message...';
          }
          if (sendBtn) {
            sendBtn.disabled = false;
          }
          if (photoBtn) {
            photoBtn.disabled = false;
          }
        }

        startOptimizedCountdown() {
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
          
          // FIXED: Use optimized interval timing with immediate first update
          this.updateCountdownOptimized();
          this.countdownInterval = setInterval(() => {
            this.updateCountdownOptimized();
          }, 1000);
        }

        updateCountdownOptimized() {
          if (!this.isActivated || !this.keyData?.expiresAt) {
            this.hideCountdown();
            return;
          }
          
          const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
          if (!expiryDate) {
            this.hideCountdown();
            return;
          }
          
          const now = new Date();
          const timeLeft = expiryDate - now;
          
          // FIXED: Instant expiry blocking when countdown reaches zero
          if (timeLeft <= 0) {
            console.log('FIXED: Countdown reached zero - instant expiry blocking');
            this.handleKeyExpiredInstantly();
            return;
          }
          
          const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
          const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
          
          let countdownText = '';
          let countdownClass = '';
          
          if (days > 0) {
            countdownText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
          } else if (hours > 0) {
            countdownText = `${hours}h ${minutes}m ${seconds}s`;
            if (hours < 24) countdownClass = 'warning';
          } else {
            countdownText = `${minutes}m ${seconds}s`;
            countdownClass = minutes < 30 ? 'critical' : 'warning';
          }
          
          this.showCountdown(countdownText, countdownClass);
        }

        showCountdown(text, className = '') {
          const countdownDisplay = document.getElementById('key-countdown-display');
          const countdownInline = document.getElementById('key-countdown');
          
          if (countdownDisplay) {
            countdownDisplay.textContent = `Expires in: ${text}`;
            countdownDisplay.className = `key-countdown ${className}`;
            countdownDisplay.style.display = 'block';
          }
          
          if (countdownInline) {
            countdownInline.textContent = text;
            countdownInline.style.display = 'inline-block';
          }
        }

        hideCountdown() {
          const countdownDisplay = document.getElementById('key-countdown-display');
          const countdownInline = document.getElementById('key-countdown');
          
          if (countdownDisplay) {
            countdownDisplay.style.display = 'none';
          }
          
          if (countdownInline) {
            countdownInline.style.display = 'none';
          }
        }

        // FIXED: Enhanced key validation with permanent UID binding
        async validateStoredKey(key, isRestore = false) {
          const startTime = performance.now();
          
          if (!window.firebaseDB || !window.firebaseModules) {
            throw new Error('Firebase not initialized');
          }
          
          // FIXED: Use ultra-persistent UID directly with enhanced fallback
          let currentUID = this.userUID || window.uidManager?.getCurrentUID();
          if (!currentUID) {
            console.log('FIXED: Waiting for ultra-persistent UID...');
            // Try to recover UID
            const recoveredUID = await this.getStoredUserUID();
            if (recoveredUID) {
              this.userUID = recoveredUID;
              currentUID = recoveredUID;
            } else {
              // Wait briefly for UID manager
              await new Promise(resolve => setTimeout(resolve, 1000));
              currentUID = this.userUID || window.uidManager?.getCurrentUID();
              if (!currentUID) {
                throw new Error('Ultra-persistent UID required for permanent activation');
              }
            }
          }
          
          const { doc, getDoc, updateDoc, serverTimestamp } = window.firebaseModules;
          
          try {
            console.log('FIXED: Validating key with permanent UID binding:', key);
            const keyDoc = await getDoc(doc(window.firebaseDB, 'activation_keys', key));
            
            if (!keyDoc.exists()) {
              throw new Error('Key does not exist or has been deleted');
            }
            
            const keyData = keyDoc.data();
            console.log('FIXED: Key data retrieved:', keyData);
            
            // FIXED: Instant expiry validation without grace period
            if (keyData.expiresAt) {
              const expiryDate = this.parseKeyDate(keyData.expiresAt);
              if (expiryDate && new Date() > expiryDate) {
                throw new Error(`Key expired on ${expiryDate.toLocaleDateString()} at ${expiryDate.toLocaleTimeString()}`);
              }
            }
            
            // One-time key validation
            if (keyData.isOneTime && keyData.isUsed) {
              throw new Error('Key has already been used');
            }
            
            // FIXED: Permanent UID binding validation
            if (keyData.userUID && keyData.userUID !== currentUID) {
              throw new Error('Key is permanently bound to a different ultra-persistent user');
            }
            
            // FIXED: Enhanced database update for permanent binding
            if (!isRestore) {
              const updateData = {
                lastAccessed: serverTimestamp(),
                accessCount: (keyData.accessCount || 0) + 1
              };
              
              // FIXED: Permanent UID binding on first use
              if (!keyData.userUID) {
                updateData.userUID = currentUID;
                updateData.activatedAt = serverTimestamp();
                updateData.activatedFrom = window.location.hostname;
                updateData.permanentBinding = true;
                updateData.ultrapersistentUID = true;
                console.log('FIXED: Creating permanent UID binding for key');
              }
              
              if (keyData.isOneTime && !keyData.isUsed) {
                updateData.isUsed = true;
                updateData.usedAt = serverTimestamp();
              }
              
              try {
                await updateDoc(doc(window.firebaseDB, 'activation_keys', key), updateData);
                console.log('FIXED: Key updated with permanent binding');
              } catch (updateError) {
                console.warn('FIXED: Non-critical update failed:', updateError);
              }
            }
            
            // FIXED: Activate with permanent ultra-persistence
            this.isActivated = true;
            this.keyData = { ...keyData, id: key };
            
            // FIXED: Store with enhanced ultra-persistence for indefinite activation
            const activationTime = Date.now();
            this.setUltraPersistentStorage(this.storageKeys.activation, key);
            this.setUltraPersistentStorage(this.storageKeys.keyData, JSON.stringify(this.keyData));
            this.setUltraPersistentStorage(this.storageKeys.keyId, key);
            this.setUltraPersistentStorage(this.storageKeys.activationTime, activationTime);
            this.setUltraPersistentStorage(this.storageKeys.lastValidation, Date.now());
            
            // FIXED: Remove any blocking immediately
            this.hideBlockedOverlay();
            
            // FIXED: Show activation animation for new activations
            if (!isRestore) {
              this.showActivationAnimation();
              
              // FIXED: Intelligent URL management
              setTimeout(() => {
                const newUrl = `${this.baseUrl}${key}`;
                const currentUrl = window.location.href;
                
                if (!currentUrl.includes(key)) {
                  window.history.replaceState({}, '', `/${key}`);
                }
              }, 3000);
            }
            
            // FIXED: Start ultra-fast realtime monitoring with zero-delay blocking
            this.startUltraFastRealtimeMonitoring(key);
            
            const expiryDate = this.parseKeyDate(keyData.expiresAt);
            const expiryText = expiryDate ? ' until ' + expiryDate.toLocaleDateString() : '';
            
            if (!isRestore) {
              this.queueToast('success', 'Permanent Activation!',
                 `Your ultra-persistent Firebase user is now permanently authorized for AI access${expiryText}. This activation persists indefinitely across all sessions and device restarts.`);
            }
            
            const endTime = performance.now();
            this.performanceMonitor.set('keyValidation', endTime - startTime);
            console.log(`FIXED: Key validation completed in ${(endTime - startTime).toFixed(2)}ms`);
            
          } catch (firestoreError) {
            console.error('FIXED: Firestore validation error:', firestoreError);
            
            if (firestoreError.code === 'permission-denied') {
              throw new Error('Permission denied. Please ensure you have a valid key.');
            } else if (firestoreError.code === 'unavailable') {
              throw new Error('Database temporarily unavailable. Please try again.');
            } else {
              throw new Error(firestoreError.message || 'Failed to validate key');
            }
          }
        }

        showActivationAnimation() {
          const animation = document.getElementById('activation-animation');
          animation.classList.add('show');
          
          setTimeout(() => {
            animation.classList.remove('show');
          }, 3000);
        }

        updateUI() {
          const keyPanel = document.getElementById('key-panel');
          const keyStatus = document.getElementById('key-status');
          const keyToggleBtn = document.getElementById('key-toggle-btn');
          const keyDetails = document.getElementById('key-details');
          const keyInfo = document.getElementById('key-info');
          const keyInput = document.getElementById('key-input');
          const keySubmitBtn = document.getElementById('key-submit-btn');
          
          if (this.isActivated && this.keyData) {
            keyPanel.classList.remove('expired', 'deleted');
            keyPanel.classList.add('activated');
            
            let statusText = '✅ Permanently Activated (Ultra-Persistent)';
            let statusClass = 'activated';
            
            if (this.keyData.expiresAt) {
              const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
              const now = new Date();
              
              if (expiryDate && now > expiryDate) {
                statusText = '❌ Expired';
                statusClass = 'expired';
                this.isActivated = false;
              } else if (expiryDate) {
                const timeLeft = expiryDate - now;
                const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                
                if (days > 0) {
                  statusText = `✅ Active (${days} days left)`;
                } else if (hours > 0) {
                  statusText = `⚠️ Active (${hours} hours left)`;
                } else {
                  statusText = `⏰ Expiring Soon`;
                }
              }
            }
            
            keyStatus.innerHTML = `🔐 Key Status: ${statusText} <span class="countdown" id="key-countdown" style="display: none;"></span>`;
            keyPanel.className = `key-panel ${statusClass}`;
            keyToggleBtn.textContent = 'User Info';
            
            if (keyInput) {
              keyInput.disabled = true;
              keyInput.placeholder = 'Permanently Activated (Ultra-Persistent UID)';
            }
            if (keySubmitBtn) {
              keySubmitBtn.disabled = true;
              keySubmitBtn.textContent = 'Activated';
            }
            
            if (keyDetails.classList.contains('show')) {
              const expiryDate = this.parseKeyDate(this.keyData.expiresAt);
              const createdDate = this.parseKeyDate(this.keyData.createdAt);
              const activationTime = this.getUltraPersistentStorage(this.storageKeys.activationTime);
              const activatedDate = activationTime ? new Date(activationTime) : null;
              
              keyInfo.innerHTML = `
                <div class="key-info-item">
                  <span class="key-info-label">Key ID:</span>
                  <span class="key-info-value">${this.keyData.id}</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">User UID:</span>
                  <span class="key-info-value">${this.userUID?.slice(0, 8)}...</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Type:</span>
                  <span class="key-info-value">${this.keyData.isOneTime ? 'One-time use' : (this.keyData.expiresAt ? 'Expiring' : 'Permanent')}</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Persistence:</span>
                  <span class="key-info-value">ULTRA-PERSISTENT (PERMANENT)</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">UID System:</span>
                  <span class="key-info-value">NEVER RESETS (Enhanced IndexedDB)</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Monitoring:</span>
                  <span class="key-info-value">Real-time (Zero-latency blocking)</span>
                </div>
                <div class="key-info-item">
                  <span class="key-info-label">Storage Layers:</span>
                  <span class="key-info-value">10+ Redundant (IndexedDB + localStorage)</span>
                </div>
                ${this.keyData.description ? `
                <div class="key-info-item">
                  <span class="key-info-label">Description:</span>
                  <span class="key-info-value">${this.keyData.description}</span>
                </div>` : ''}
                ${createdDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Created:</span>
                  <span class="key-info-value">${createdDate.toLocaleDateString()} ${createdDate.toLocaleTimeString()}</span>
                </div>` : ''}
                ${activatedDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Activated:</span>
                  <span class="key-info-value">${activatedDate.toLocaleDateString()} ${activatedDate.toLocaleTimeString()}</span>
                </div>` : ''}
                ${expiryDate ? `
                <div class="key-info-item">
                  <span class="key-info-label">Expires:</span>
                  <span class="key-info-value">${expiryDate.toLocaleDateString()} ${expiryDate.toLocaleTimeString()}</span>
                </div>` : ''}
                <div class="key-info-item">
                  <span class="key-info-label">Access Count:</span>
                  <span class="key-info-value">${this.keyData.accessCount || 0}</span>
                </div>
              `;
            }
          } else {
            keyPanel.classList.remove('activated');
            
            if (keyInput) {
              keyInput.disabled = false;
              keyInput.placeholder = 'Enter your activation key...';
            }
            if (keySubmitBtn) {
              keySubmitBtn.disabled = false;
              keySubmitBtn.textContent = 'Activate';
            }
            
            const storedKeyData = this.getUltraPersistentStorage(this.storageKeys.keyData);
            if (storedKeyData) {
              try {
                const parsed = JSON.parse(storedKeyData);
                if (parsed.expiresAt && new Date() > new Date(parsed.expiresAt)) {
                  keyPanel.classList.add('expired');
                  keyStatus.textContent = '🔐 Key Status: Expired (Ultra-Persistent UID Maintained)';
                } else {
                  keyPanel.classList.add('deleted');
                  keyStatus.textContent = '🔐 Key Status: Deleted (Ultra-Persistent UID Maintained)';
                }
              } catch (e) {
                keyPanel.classList.remove('expired', 'deleted');
                keyStatus.textContent = '🔐 Key Status: Not Activated';
              }
            } else {
              keyPanel.classList.remove('expired', 'deleted');
              keyStatus.textContent = '🔐 Key Status: Not Activated';
            }
            
            keyToggleBtn.textContent = 'Activate';
            keyInfo.innerHTML = '<div class="key-info-item"><span class="key-info-value">Enter your activation key to authorize this ultra-persistent Firebase user for AI capabilities. Your UID will NEVER reset and activation persists permanently across browser restarts, phone shutdowns, and app exits.</span></div>';
          }
          
          // FIXED: Block AI functionality if not activated
          if (!this.isActivated || this.isBlocked) {
            this.blockAIFunctionality();
          }
        }

        // FIXED: Enhanced AI functionality blocking
        blockAIFunctionality() {
          if (window.streamAIResponse && !window.streamAIResponse._blocked) {
            window.originalStreamAIResponse = window.streamAIResponse;
            window.streamAIResponse = function() {
              appendMessage("🔒 Please activate your user key to use AI features. Your ultra-persistent UID is maintained - just enter your key above to restore full functionality.", 'ai', false, false);
              showToast('warning', 'Activation Required', 'Please activate your key to access AI functionality. Your UID is permanently saved.');
            };
            window.streamAIResponse._blocked = true;
          }
        }

        queueToast(type, title, message) {
          if (this.systemReady && this.initializationComplete) {
            showToast(type, title, message);
          }
        }

        async activateKey(key) {
          try {
            document.getElementById('key-submit-btn').disabled = true;
            document.getElementById('key-submit-btn').textContent = 'Activating...';
            
            await this.validateStoredKey(key.toUpperCase());
            this.updateUI();
            
            document.getElementById('key-input').value = '';
            
            // FIXED: Restore AI functionality
            if (window.originalStreamAIResponse) {
              window.streamAIResponse = window.originalStreamAIResponse;
              delete window.streamAIResponse._blocked;
            }
          } catch (error) {
            showToast('error', 'Activation Failed', error.message);
            console.error('FIXED: Key activation failed:', error);
          } finally {
            if (!this.isActivated) {
              document.getElementById('key-submit-btn').disabled = false;
              document.getElementById('key-submit-btn').textContent = 'Activate';
            }
          }
        }

        deactivateKey() {
          this.isActivated = false;
          this.keyData = null;
          this.clearPerpetuallySavedActivation();
          
          if (this.realtimeListener) {
            this.realtimeListener();
            this.realtimeListener = null;
          }
          
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
            this.countdownInterval = null;
          }
          
          this.hideCountdown();
          this.hideBlockedOverlay();
          this.updateUI();
          showToast('info', 'Key Deactivated', 'Ultra-persistent authorization removed. Your UID is maintained for quick re-activation.');
        }

        destroy() {
          if (this.realtimeListener) {
            this.realtimeListener();
          }
          
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
          
          this.hideBlockedOverlay();
          
          // FIXED: Log performance stats
          console.log('FIXED: Key System Performance Stats:', Object.fromEntries(this.performanceMonitor));
        }
      }

      // FIXED: Initialize the ultra-persistent key system
      let keySystem = new UltraPersistentKeySystem();

      // FIXED: Global functions for enhanced blocking system
      window.handleUnderstandAction = function() {
        if (keySystem) {
          // Clear the blocked overlay
          keySystem.hideBlockedOverlay();
          
          // Reset to "Not Activated" state without clearing UID
          keySystem.isActivated = false;
          keySystem.isBlocked = false;
          keySystem.keyData = null;
          
          // Update UI to show "Not Activated"  
          keySystem.updateUI();
          
          // Show success toast
          showToast('success', 'Ready for New Activation', 'Your UID remains persistent');
        }
      };

      window.showContactModal = function() {
        // Remove any existing contact modal
        const existingModal = document.querySelector('.contact-modal');
        if (existingModal) {
          existingModal.remove();
        }
        
        const modal = document.createElement('div');
        modal.className = 'contact-modal';
        modal.innerHTML = `
          <div class="contact-modal-content">
            <h3>Choose contact method:</h3>
            <div>
              <button class="contact-option whatsapp" onclick="openWhatsApp()">
                📱 WhatsApp
              </button>
              <button class="contact-option gmail" onclick="openGmail()">
                📧 Gmail
              </button>
              <button class="contact-option cancel" onclick="closeContactModal()">
                ❌ Cancel
              </button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      };

      window.openWhatsApp = function() {
        try {
          window.open('https://wa.me/639454488235', '_blank');
        } catch (error) {
          console.error('Failed to open WhatsApp:', error);
          showToast('error', 'Contact Error', 'Failed to open WhatsApp. Please try again.');
        }
        closeContactModal();
      };

      window.openGmail = function() {
        try {
          window.open('mailto:barnigonzales43329@gmail.com', '_blank');
        } catch (error) {
          console.error('Failed to open Gmail:', error);
          showToast('error', 'Contact Error', 'Failed to open Gmail. Please try again.');
        }
        closeContactModal();
      };

      window.closeContactModal = function() {
        const modal = document.querySelector('.contact-modal');
        if (modal) {
          modal.remove();
        }
      };

      // GoFile API Configuration - Performance Optimized
      const GOFILE_API_TOKEN = 'j4yXffP0QupranFzYZUY6DoKMLan7fw8';
      const GOFILE_BASE_URL = 'https://api.gofile.io';
      const UPLOAD_URL = 'https://upload.gofile.io/uploadfile';

      // Ultra-Optimized Cloud Storage Manager
      class UltraOptimizedGoFileStorage {
        constructor() {
          this.token = GOFILE_API_TOKEN;
          this.folderId = null;
          this.accountId = null;
          this.storageKey = 'ai_chatbot_data';
          this.syncInProgress = false;
          this.lastSync = 0;
          this.syncInterval = 45000;
          this.retryAttempts = 3;
          this.retryDelay = 2000;
          this.dataFileId = null;
          this.initialized = false;
          this.isConnected = false;
          this.connectionCheckInterval = null;
          this.autoSyncInterval = null;
          this.performanceCache = new Map();
        }

        updateConnectionStatus(connected, message = '') {
          const indicator = document.getElementById('connection-indicator');
          const text = document.getElementById('connection-text');
          
          this.isConnected = connected;
          
          if (connected) {
            indicator.classList.add('connected');
            text.textContent = 'GoFile Connected';
          } else {
            indicator.classList.remove('connected');
            text.textContent = message || 'GoFile Disconnected';
          }
        }

        showSyncStatus(message, show = true) {
          const syncStatus = document.getElementById('sync-status');
          const syncMessage = document.getElementById('sync-message');
          
          if (syncMessage) {
            syncMessage.textContent = message;
          }
          
          if (show) {
            syncStatus.classList.add('show');
          } else {
            setTimeout(() => syncStatus.classList.remove('show'), 2000);
          }
        }

        async initialize() {
          if (this.initialized) return this.isConnected;
          
          try {
            this.showSyncStatus('Connecting to GoFile cloud...');
            this.updateConnectionStatus(false, 'Connecting...');
            
            const accountResponse = await fetch(`${GOFILE_BASE_URL}/accounts/getid`, {
              headers: {
                'Authorization': `Bearer ${this.token}`
              }
            });
            
            if (!accountResponse.ok) {
              throw new Error(`GoFile authentication failed: ${accountResponse.status}`);
            }
            
            const accountData = await accountResponse.json();
            if (accountData.status !== 'ok') {
              throw new Error('GoFile authentication unsuccessful');
            }
            
            this.accountId = accountData.data.id;
            
            const storedFileId = this.getStoredFileId();
            if (storedFileId) {
              this.dataFileId = storedFileId;
            }
            
            this.initialized = true;
            this.updateConnectionStatus(true);
            this.showSyncStatus('Connected to GoFile cloud ✓', false);
            
            showToast('success', 'Cloud Connected', 'GoFile cloud storage is now active');
            
            this.startConnectionMonitoring();
            this.startAutoSync();
            
            return true;
          } catch (error) {
            console.error('GoFile initialization failed:', error);
            this.updateConnectionStatus(false, 'Connection Failed');
            this.showSyncStatus('GoFile connection failed', false);
            showToast('error', 'Cloud Error', 'Failed to connect to GoFile. Please check your connection.');
            return false;
          }
        }

        getStoredFileId() {
          try {
            return sessionStorage.getItem('gofile_data_file_id');
          } catch (e) {
            return null;
          }
        }

        setStoredFileId(fileId) {
          try {
            sessionStorage.setItem('gofile_data_file_id', fileId);
          } catch (e) {
            console.warn('Failed to store file ID');
          }
        }

        clearStoredData() {
          try {
            sessionStorage.removeItem('gofile_data_file_id');
            sessionStorage.removeItem('gofile_folder_id');
          } catch (e) {
            // Ignore errors
          }
          this.dataFileId = null;
          this.folderId = null;
        }

        async createDataFile(data) {
          try {
            const jsonData = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `chatbot_data_${timestamp}.json`;
            
            const formData = new FormData();
            formData.append('file', blob, fileName);
            
            if (this.folderId) {
              formData.append('folderId', this.folderId);
            }
            
            const uploadResponse = await fetch(UPLOAD_URL, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${this.token}`
              },
              body: formData
            });
            
            if (!uploadResponse.ok) {
              throw new Error(`Upload failed: ${uploadResponse.status}`);
            }
            
            const uploadData = await uploadResponse.json();
            
            if (uploadData.status === 'ok') {
              this.dataFileId = uploadData.data.fileId;
              this.setStoredFileId(this.dataFileId);
              
              if (!this.folderId && uploadData.data.parentFolder) {
                this.folderId = uploadData.data.parentFolder;
                try {
                  sessionStorage.setItem('gofile_folder_id', this.folderId);
                } catch (e) {
                  // Ignore storage errors
                }
              }
              
              return true;
            }
            
            throw new Error('Upload response unsuccessful');
          } catch (error) {
            console.error('Failed to create data file:', error);
            throw error;
          }
        }

        async updateDataFile(data) {
          if (this.dataFileId) {
            try {
              await fetch(`${GOFILE_BASE_URL}/contents`, {
                method: 'DELETE',
                headers: {
                  'Authorization': `Bearer ${this.token}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  contentsId: this.dataFileId
                })
              });
            } catch (e) {
              console.warn('Failed to delete old file:', e);
            }
          }
          
          return await this.createDataFile(data);
        }

        async saveToCloud(data, isAutoSync = false) {
          if (this.syncInProgress) return false;
          
          this.syncInProgress = true;
          
          if (!isAutoSync) {
            this.showSyncStatus('Saving to GoFile cloud...');
          }
          
          if (!this.initialized) {
            const connected = await this.initialize();
            if (!connected) {
              this.syncInProgress = false;
              return false;
            }
          }
          
          let attempts = 0;
          while (attempts < this.retryAttempts) {
            try {
              const saveData = {
                conversations: this.serializeMap(conversations),
                advancedMemory: {
                  conversations: this.serializeMap(advancedMemory.conversations, (conv) => ({
                    ...conv,
                    topics: Array.from(conv.topics),
                    messages: conv.messages
                  })),
                  globalTopics: this.serializeMap(advancedMemory.globalTopics, (convIds) => Array.from(convIds)),
                  conversationTopics: Array.from(advancedMemory.conversationTopics.entries())
                },
                currentConversationId,
                lastUpdated: Date.now(),
                version: '6.0',
                metadata: {
                  totalConversations: conversations.size,
                  totalMemoryEntries: advancedMemory.conversations.size,
                  saveType: isAutoSync ? 'auto' : 'manual',
                  uidSystem: 'ultra-persistent'
                }
              };
              
              const success = this.dataFileId ?
                await this.updateDataFile(saveData) :
                await this.createDataFile(saveData);
              
              if (success) {
                this.lastSync = Date.now();
                this.updateConnectionStatus(true);
                
                if (!isAutoSync) {
                  this.showSyncStatus('Saved to GoFile cloud ✓', false);
                }
                
                this.syncInProgress = false;
                return true;
              }
            } catch (error) {
              attempts++;
              console.error(`Save attempt ${attempts} failed:`, error);
              
              if (attempts >= this.retryAttempts) {
                this.updateConnectionStatus(false, 'Save Failed');
                
                if (!isAutoSync) {
                  this.showSyncStatus('GoFile save failed', false);
                  showToast('error', 'Cloud Save Failed', 'Failed to save to GoFile cloud.');
                }
                
                this.syncInProgress = false;
                return false;
              } else {
                await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempts));
              }
            }
          }
          
          this.syncInProgress = false;
          return false;
        }

        async loadFromCloud() {
          if (!this.initialized) {
            const connected = await this.initialize();
            if (!connected) {
              return this.getEmptyData();
            }
          }
          
          if (!this.dataFileId) {
            this.showSyncStatus('No cloud backup found', false);
            return this.getEmptyData();
          }
          
          this.showSyncStatus('Loading from GoFile cloud...');
          
          try {
            const detailsResponse = await fetch(`${GOFILE_BASE_URL}/contents/${this.dataFileId}`, {
              headers: {
                'Authorization': `Bearer ${this.token}`
              }
            });
            
            if (!detailsResponse.ok) {
              throw new Error(`Failed to get file details: ${detailsResponse.status}`);
            }
            
            const detailsData = await detailsResponse.json();
            
            if (detailsData.status !== 'ok') {
              throw new Error('Failed to get file details from GoFile');
            }
            
            let fileInfo = null;
            if (detailsData.data.children) {
              fileInfo = Object.values(detailsData.data.children).find(child =>
                  child.id === this.dataFileId && child.type === 'file'
              );
            }
            
            if (!fileInfo || !fileInfo.link) {
              throw new Error('Data file not found or no download link');
            }
            
            const fileResponse = await fetch(fileInfo.link);
            if (!fileResponse.ok) {
              throw new Error(`Failed to download file: ${fileResponse.status}`);
            }
            
            const fileData = await fileResponse.json();
            
            this.showSyncStatus('Loaded from GoFile cloud ✓', false);
            this.updateConnectionStatus(true);
            
            return fileData;
          } catch (error) {
            console.error('Failed to load from GoFile:', error);
            this.updateConnectionStatus(false, 'Load Failed');
            this.showSyncStatus('GoFile load failed', false);
            showToast('warning', 'Cloud Load Failed', 'Could not load from cloud storage.');
            return this.getEmptyData();
          }
        }

        serializeMap(map, valueTransformer = null) {
          const result = {};
          for (const [key, value] of map.entries()) {
            result[key] = valueTransformer ? valueTransformer(value) : value;
          }
          return result;
        }

        getEmptyData() {
          return {
            conversations: {},
            advancedMemory: {
              conversations: {},
              globalTopics: {},
              conversationTopics: []
            },
            currentConversationId: null,
            version: '6.0'
          };
        }

        startConnectionMonitoring() {
          if (this.connectionCheckInterval) {
            clearInterval(this.connectionCheckInterval);
          }
          
          this.connectionCheckInterval = setInterval(async () => {
            if (!this.initialized) return;
            
            try {
              const response = await fetch(`${GOFILE_BASE_URL}/accounts/getid`, {
                headers: { 'Authorization': `Bearer ${this.token}` }
              });
              
              const isConnected = response.ok;
              this.updateConnectionStatus(isConnected, isConnected ? null : 'Connection Lost');
            } catch (error) {
              this.updateConnectionStatus(false, 'Connection Error');
            }
          }, 60000);
        }

        startAutoSync() {
          if (this.autoSyncInterval) {
            clearInterval(this.autoSyncInterval);
          }
          
          this.autoSyncInterval = setInterval(async () => {
            if (this.isConnected && !this.syncInProgress &&
                Date.now() - this.lastSync > this.syncInterval) {
              await this.saveToCloud({
                conversations,
                advancedMemory,
                currentConversationId
              }, true);
            }
          }, this.syncInterval);
        }

        async clearAllData() {
          this.clearStoredData();
          this.lastSync = 0;
          this.updateConnectionStatus(this.initialized);
        }

        destroy() {
          if (this.connectionCheckInterval) {
            clearInterval(this.connectionCheckInterval);
          }
          if (this.autoSyncInterval) {
            clearInterval(this.autoSyncInterval);
          }
        }
      }

      // Initialize ultra-optimized cloud storage
      const cloudStorage = new UltraOptimizedGoFileStorage();

      // OpenRouter model list with vision capabilities
      const openRouterModels = [
        { id: "openrouter:01-ai/yi-large", hasVision: false },
        { id: "openrouter:anthropic/claude-3-haiku", hasVision: true },
        { id: "openrouter:anthropic/claude-3-opus", hasVision: true },
        { id: "openrouter:anthropic/claude-3-sonnet", hasVision: true },
        { id: "openrouter:anthropic/claude-3.5-haiku", hasVision: true },
        { id: "openrouter:anthropic/claude-3.5-sonnet", hasVision: true },
        { id: "openrouter:anthropic/claude-sonnet-4", hasVision: true },
        { id: "openrouter:anthropic/claude-opus-4", hasVision: true },
        { id: "openrouter:google/gemini-2.0-flash-001", hasVision: true },
        { id: "openrouter:google/gemini-flash-1.5", hasVision: true },
        { id: "openrouter:google/gemini-pro-1.5", hasVision: true },
        { id: "openrouter:google/gemma-2-27b-it", hasVision: false },
        { id: "openrouter:meta-llama/llama-3.2-11b-vision-instruct", hasVision: true },
        { id: "openrouter:meta-llama/llama-3.2-90b-vision-instruct", hasVision: true },
        { id: "openrouter:mistralai/pixtral-12b", hasVision: true },
        { id: "openrouter:mistralai/pixtral-large-2411", hasVision: true },
        { id: "openrouter:openai/gpt-4-turbo", hasVision: true },
        { id: "openrouter:openai/gpt-4o", hasVision: true },
        { id: "openrouter:openai/gpt-4o-mini", hasVision: true },
        { id: "openrouter:qwen/qwen-2.5-vl-7b-instruct", hasVision: true },
        { id: "openrouter:qwen/qwen-vl-max", hasVision: true },
        { id: "openrouter:deepseek/deepseek-chat", hasVision: false },
        { id: "openrouter:openai/chatgpt-4o-latest", hasVision: true },
        { id: "openrouter:microsoft/phi-4-multimodal-instruct", hasVision: true }
      ];

      // Image handling variables
      let attachedImages = [];
      const MAX_IMAGES = 5;
      const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

      // Ultra-optimized toast system
      function showToast(type, title, message, duration = 4000) {
        const toastContainer = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        const icons = {
          success: '✓',
          error: '✕',
          warning: '⚠',
          info: 'ℹ'
        };

        toast.innerHTML = `
          <div class="toast-icon">${icons[type] || icons.info}</div>
          <div class="toast-content">
            <div class="toast-title">${title}</div>
            <div class="toast-message">${message}</div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">✕</button>
        `;

        toastContainer.appendChild(toast);

        // Trigger animation
        requestAnimationFrame(() => toast.classList.add('show'));

        // Auto remove
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      // Theme management
      const themeToggle = document.getElementById('theme-toggle');
      const htmlElement = document.documentElement;

      function loadTheme() {
        const savedTheme = sessionStorage.getItem('theme') || 'light';
        htmlElement.setAttribute('data-theme', savedTheme);
        themeToggle.checked = savedTheme === 'dark';
      }

      function toggleTheme() {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        htmlElement.setAttribute('data-theme', newTheme);
        sessionStorage.setItem('theme', newTheme);
      }

      loadTheme();
      themeToggle.addEventListener('change', toggleTheme);

      // Chat functionality with performance optimizations
      const chatContainer = document.getElementById('chat-container');
      const userInput = document.getElementById('user-input');
      const sendBtn = document.getElementById('send-btn');
      const modelSelect = document.getElementById('model-select');
      const conversationSelect = document.getElementById('conversation-select');
      const newConversationBtn = document.getElementById('new-conversation-btn');
      const deleteConversationBtn = document.getElementById('delete-conversation-btn');
      const clearMemoryBtn = document.getElementById('clear-memory-btn');
      const memoryPanel = document.getElementById('memory-panel');
      const memoryContent = document.getElementById('memory-content');
      const fileInput = document.getElementById('file-input');
      const photoBtn = document.getElementById('photo-btn');
      const imagePreviewContainer = document.getElementById('image-preview-container');
      const imagePreviews = document.getElementById('image-previews');

      // Optimized image handling
      function handleImageSelect(e) {
        const files = Array.from(e.target.files);

        if (attachedImages.length + files.length > MAX_IMAGES) {
          showToast('warning', 'Too Many Images', `You can only attach up to ${MAX_IMAGES} images at once.`);
          return;
        }

        files.forEach(file => {
          if (!file.type.startsWith('image/')) {
            showToast('error', 'Invalid File', `${file.name} is not an image file.`);
            return;
          }

          if (file.size > MAX_FILE_SIZE) {
            showToast('error', 'File Too Large', `${file.name} exceeds the 10MB size limit.`);
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            attachedImages.push({
              file: file,
              dataUrl: e.target.result,
              name: file.name
            });
            updateImagePreviews();
          };
          reader.readAsDataURL(file);
        });

        fileInput.value = '';
      }

      function updateImagePreviews() {
        if (attachedImages.length === 0) {
          imagePreviewContainer.style.display = 'none';
          imagePreviews.innerHTML = '';
          return;
        }

        imagePreviewContainer.style.display = 'block';
        imagePreviews.innerHTML = attachedImages.map((img, index) => `
          <div class="image-preview-wrapper">
            <img src="${img.dataUrl}" alt="${img.name}" class="image-preview" onclick="openImageModal('${img.dataUrl}')">
            <button class="remove-image" onclick="removeImage(${index})" aria-label="Remove image">✕</button>
          </div>
        `).join('');
      }

      window.removeImage = function(index) {
        attachedImages.splice(index, 1);
        updateImagePreviews();
        showToast('info', 'Image Removed', 'Image has been removed from attachments.');
      };

      window.openImageModal = function(src) {
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        modal.style.display = 'block';
        modalImg.src = src;
      };

      window.closeImageModal = function() {
        document.getElementById('imageModal').style.display = 'none';
      };

      // Close modal when clicking outside
      window.onclick = function(event) {
        const modal = document.getElementById('imageModal');
        if (event.target === modal) {
          closeImageModal();
        }
      };

      // Ultra-optimized advanced memory system
      let advancedMemory = {
        conversations: new Map(),
        globalTopics: new Map(),
        conversationTopics: new Map()
      };

      // Populate model selector
      function populateModelSelector() {
        modelSelect.innerHTML = '<option value="" disabled selected>Select a model</option>';
        openRouterModels.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          const modelName = model.id.replace(/^openrouter:/, '');
          option.textContent = modelName + (model.hasVision ? ' 👁️' : '');
          option.dataset.hasVision = model.hasVision;
          modelSelect.appendChild(option);
        });
      }

      // Conversation management with performance optimization
      let conversations = new Map();
      let currentConversationId = null;

      // Optimized topic extraction
      function extractTopicsFromText(text) {
        if (!text || typeof text !== 'string') return [];

        const topics = new Set();
        const lowerText = text.toLowerCase();

        const techKeywords = [
          'javascript', 'python', 'java', 'react', 'vue', 'angular', 'node', 'typescript',
          'html', 'css', 'sql', 'database', 'api', 'rest', 'graphql', 'git', 'docker',
          'kubernetes', 'aws', 'azure', 'programming', 'coding', 'development', 'software',
          'frontend', 'backend', 'fullstack', 'web', 'mobile', 'app', 'ai', 'machine learning',
          'image', 'photo', 'picture', 'vision', 'visual', 'analyze', 'detect', 'recognition'
        ];

        techKeywords.forEach(keyword => {
          if (lowerText.includes(keyword)) {
            topics.add(keyword);
          }
        });

        const questionPatterns = ['how to', 'what is', 'why does', 'when should', 'where can', 'analyze this', 'look at'];
        questionPatterns.forEach(pattern => {
          if (lowerText.includes(pattern)) {
            const match = lowerText.match(new RegExp(pattern + ' ([a-z]+(?:\\s+[a-z]+){0,2})'));
            if (match && match[1]) {
              topics.add(match[1].trim());
            }
          }
        });

        return Array.from(topics).slice(0, 10);
      }

      function generateConversationTitle(firstMessage, hasImages = false) {
        if (!firstMessage || typeof firstMessage !== 'string') return hasImages ? 'Image Analysis' : 'New Conversation';

        const topics = extractTopicsFromText(firstMessage);
        if (topics.length > 0) {
          const prefix = hasImages ? '🖼️ ' : '';
          return prefix + topics.slice(0, 2).map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
        }

        const prefix = hasImages ? '🖼️ ' : '';
        return prefix + (firstMessage.substring(0, 50).trim() + (firstMessage.length > 50 ? '...' : '') || 'New Conversation');
      }

      function updateAdvancedMemory(userMessage, aiResponse, convId, images = []) {
        if (!userMessage || !aiResponse || !convId) return;

        const userTopics = extractTopicsFromText(userMessage);
        const aiTopics = extractTopicsFromText(aiResponse);
        if (images.length > 0) {
          userTopics.push('image', 'visual');
        }
        const allTopics = [...new Set([...userTopics, ...aiTopics])];

        if (!advancedMemory.conversations.has(convId)) {
          advancedMemory.conversations.set(convId, {
            id: convId,
            title: generateConversationTitle(userMessage, images.length > 0),
            messages: [],
            topics: new Set(),
            createdAt: new Date().toISOString(),
            lastUpdated: Date.now(),
            hasImages: images.length > 0
          });
        }

        const conv = advancedMemory.conversations.get(convId);

        allTopics.forEach(topic => {
          conv.topics.add(topic);

          if (!advancedMemory.globalTopics.has(topic)) {
            advancedMemory.globalTopics.set(topic, new Set());
          }
          advancedMemory.globalTopics.get(topic).add(convId);
        });

        conv.messages.push({
          user: userMessage,
          ai: aiResponse,
          timestamp: Date.now(),
          topics: allTopics,
          images: images
        });

        conv.lastUpdated = Date.now();
        if (images.length > 0) conv.hasImages = true;

        advancedMemory.conversationTopics.set(convId, Array.from(conv.topics));

        cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();
      }

      function getFullConversationHistory(convId) {
        const conv = advancedMemory.conversations.get(convId);
        if (!conv) return [];

        return conv.messages.map(msg => [
          { role: 'user', content: msg.user },
          { role: 'assistant', content: msg.ai }
        ]).flat();
      }

      function buildContextualPrompt(userInput, convId, images = []) {
        const conv = advancedMemory.conversations.get(convId);
        const recentHistory = conv ? conv.messages.slice(-5) : [];

        let contextPrompt = '';

        if (images.length > 0 && (!userInput || userInput.trim() === '')) {
          contextPrompt = `[IMAGE ANALYSIS REQUEST] The user has attached ${images.length} image(s) for analysis.\n\n`;
          contextPrompt += 'Please analyze the attached image(s) and provide detailed insights.';
        } else if (images.length > 0) {
          contextPrompt = `[USER MESSAGE WITH ${images.length} IMAGE(S)]\n\n`;

          if (recentHistory.length > 0) {
            contextPrompt += `[CONVERSATION CONTEXT] This conversation has ${conv.messages.length} previous exchanges. Topics discussed: ${Array.from(conv.topics).join(', ')}.  Recent conversation history: ${recentHistory.map(msg => `User: ${msg.user}\nAssistant: ${msg.ai.substring(0, 200)}...`).join('\n\n')}  [CURRENT MESSAGE]: ${userInput}  Please respond to the user's message while considering the attached image(s) and the conversation history.`;
          } else {
            contextPrompt += userInput;
          }
        } else {
          if (recentHistory.length > 0) {
            contextPrompt += `[CONVERSATION MEMORY] This conversation has ${conv.messages.length} previous exchanges. Topics discussed: ${Array.from(conv.topics).join(', ')}.  Recent conversation history: ${recentHistory.map(msg => `User: ${msg.user}\nAssistant: ${msg.ai.substring(0, 200)}...`).join('\n\n')}  [CURRENT QUESTION]: ${userInput}  Please provide a detailed response that takes into account the entire conversation history.`;
          } else {
            contextPrompt = userInput;
          }
        }

        return contextPrompt;
      }

      async function loadAdvancedMemory() {
        try {
          const cloudData = await cloudStorage.loadFromCloud();

          if (cloudData && cloudData.advancedMemory) {
            const parsed = cloudData.advancedMemory;

            advancedMemory.conversations = new Map();
            if (parsed.conversations) {
              Object.entries(parsed.conversations).forEach(([id, conv]) => {
                advancedMemory.conversations.set(id, {
                  ...conv,
                  topics: new Set(conv.topics || []),
                  messages: conv.messages || []
                });
              });
            }

            advancedMemory.globalTopics = new Map();
            if (parsed.globalTopics) {
              Object.entries(parsed.globalTopics).forEach(([topic, convIds]) => {
                advancedMemory.globalTopics.set(topic, new Set(convIds));
              });
            }

            advancedMemory.conversationTopics = new Map(parsed.conversationTopics || []);
          }
        } catch (e) {
          console.error('Error loading advanced memory:', e);
        }

        updateMemoryDisplay();
      }

      function updateMemoryDisplay() {
        const hasMemory = advancedMemory.conversations.size > 0;

        if (!hasMemory) {
          memoryPanel.style.display = 'none';
          return;
        }

        memoryPanel.style.display = 'block';
        memoryContent.innerHTML = '';

        const topicCounts = new Map();
        advancedMemory.globalTopics.forEach((convIds, topic) => {
          topicCounts.set(topic, convIds.size);
        });

        const sortedTopics = Array.from(topicCounts.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 15);

        if (sortedTopics.length > 0) {
          const topicsContainer = document.createElement('div');
          topicsContainer.innerHTML = '<div style="font-weight: 600; margin-bottom: 0.5rem;">Popular Topics:</div>';

          sortedTopics.forEach(([topic, count]) => {
            const tag = document.createElement('span');
            tag.className = 'topic-tag';
            tag.textContent = `${topic} (${count})`;
            tag.onclick = () => {
              userInput.value = `Tell me more about ${topic}`;
              userInput.focus();
            };
            topicsContainer.appendChild(tag);
          });

          memoryContent.appendChild(topicsContainer);
        }

        const recentConvs = Array.from(advancedMemory.conversations.values())
          .sort((a, b) => b.lastUpdated - a.lastUpdated)
          .slice(0, 3);

        if (recentConvs.length > 0) {
          recentConvs.forEach(conv => {
            const convDiv = document.createElement('div');
            convDiv.className = 'conversation-topic';
            convDiv.innerHTML = `
              <div class="conversation-title">${conv.title}</div>
              <div class="conversation-summary">${conv.messages.length} messages • ${Array.from(conv.topics).slice(0, 3).join(', ')}</div>
              <div class="conversation-date">${new Date(conv.createdAt).toLocaleDateString()}</div>
            `;
            convDiv.onclick = () => {
              currentConversationId = conv.id;
              conversationSelect.value = conv.id;
              renderMessages();
            };
            memoryContent.appendChild(convDiv);
          });
        }
      }

      async function clearAdvancedMemory() {
        showToast('warning', 'Clear Memory', 'This will permanently delete all conversation memory. Are you sure?', 5000);

        const confirmToast = document.createElement('div');
        confirmToast.className = 'toast warning show';
        confirmToast.innerHTML = `
          <div class="toast-icon">⚠</div>
          <div class="toast-content">
            <div class="toast-title">Confirm Clear Memory</div>
            <div class="toast-message">
              <div style="margin-bottom: 0.5rem;">This cannot be undone!</div>
              <button onclick="confirmClearMemory(this)" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; cursor: pointer;">Clear All</button>
              <button onclick="this.closest('.toast').remove()" style="background: #6b7280; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer;">Cancel</button>
            </div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">✕</button>
        `;

        document.getElementById('toast-container').appendChild(confirmToast);
      }

      window.confirmClearMemory = async function(button) {
        advancedMemory = {
          conversations: new Map(),
          globalTopics: new Map(),
          conversationTopics: new Map()
        };

        await cloudStorage.clearAllData();
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();

        button.closest('.toast').remove();
        showToast('success', 'Memory Cleared', 'All conversation memory has been successfully cleared.');
        appendMessage('🧠 Advanced memory has been cleared.', 'ai', false, false);
      };

      // Optimized conversation management
      async function loadConversations() {
        try {
          const cloudData = await cloudStorage.loadFromCloud();

          if (cloudData) {
            if (cloudData.conversations) {
              conversations = new Map(Object.entries(cloudData.conversations));
            }

            if (cloudData.currentConversationId) {
              currentConversationId = cloudData.currentConversationId;
            }
          }
        } catch (e) {
          console.error('Failed to load conversations:', e);
        }

        if (conversations.size === 0) {
          createNewConversation();
        } else {
          if (!currentConversationId) {
            currentConversationId = Array.from(conversations.keys())[0];
          }
          updateConversationSelect();
          renderMessages();
        }

        await loadAdvancedMemory();
      }

      async function createNewConversation() {
        const id = `conv_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        conversations.set(id, []);
        currentConversationId = id;
        updateConversationSelect();
        renderMessages();
        appendMessage('👋 Welcome to a new conversation! I can analyze images and remember all our previous chats. What would you like to discuss?', 'ai', false, false);
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        showToast('success', 'New Conversation', 'Started a new conversation with full memory context.');
      }

      async function deleteConversation() {
        if (!currentConversationId || conversations.size <= 1) {
          showToast('warning', 'Cannot Delete', 'Cannot delete the last conversation.');
          return;
        }

        const conv = advancedMemory.conversations.get(currentConversationId);
        const title = conv ? conv.title : 'this conversation';

        const confirmToast = document.createElement('div');
        confirmToast.className = 'toast error show';
        confirmToast.innerHTML = `
          <div class="toast-icon">🗑️</div>
          <div class="toast-content">
            <div class="toast-title">Delete Conversation</div>
            <div class="toast-message">
              <div style="margin-bottom: 0.5rem;">Delete "${title}"?</div>
              <button onclick="confirmDeleteConversation(this)" style="background: #dc2626; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; margin-right: 0.5rem; cursor: pointer;">Delete</button>
              <button onclick="this.closest('.toast').remove()" style="background: #6b7280; color: white; border: none; padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer;">Cancel</button>
            </div>
          </div>
          <button class="toast-close" onclick="this.parentElement.remove()">✕</button>
        `;

        document.getElementById('toast-container').appendChild(confirmToast);
      }

      window.confirmDeleteConversation = async function(button) {
        const conv = advancedMemory.conversations.get(currentConversationId);
        const title = conv ? conv.title : 'Conversation';

        advancedMemory.conversations.delete(currentConversationId);
        conversations.delete(currentConversationId);
        currentConversationId = Array.from(conversations.keys())[0];
        updateConversationSelect();
        renderMessages();
        await cloudStorage.saveToCloud({
          conversations,
          advancedMemory,
          currentConversationId
        });
        updateMemoryDisplay();
        button.closest('.toast').remove();
        showToast('success', 'Conversation Deleted', `"${title}" has been successfully deleted.`);
      };

      function updateConversationSelect() {
        conversationSelect.innerHTML = '';
        Array.from(conversations.keys()).forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          const conv = advancedMemory.conversations.get(id);
          const title = conv
              ? conv.title.substring(0, 30) + (conv.title.length > 30 ? '...' : '')
            : `Conversation ${id.slice(-4)}`;
          option.textContent = title;
          conversationSelect.appendChild(option);
        });
        conversationSelect.value = currentConversationId;
        deleteConversationBtn.disabled = conversations.size <= 1;
      }

      function renderMessages() {
        chatContainer.innerHTML = '';
        const messages = conversations.get(currentConversationId) || [];
        
        let messageIndex = 0;
        
        function renderNextMessage() {
          if (messageIndex < messages.length) {
            const msg = messages[messageIndex];
            if (msg.images && msg.images.length > 0 && msg.role === 'user') {
              appendMessage(msg.content, msg.role, false, msg.role === 'user', msg.images);
            } else {
              appendMessage(msg.content, msg.role, false, msg.role === 'user');
            }
            messageIndex++;
            requestAnimationFrame(renderNextMessage);
          } else {
            requestAnimationFrame(() => scrollToBottom());
          }
        }
        
        renderNextMessage();
      }

      function formatTimestamp() {
        return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      function detectLanguage(code) {
        const langPatterns = [
          { pattern: /(?:import|export|function|const|let|var|=>|\{|\})/g, lang: 'javascript' },
          { pattern: /(?:def\s|import\s|from\s|class\s|if\s.*:|for\s.*:|while\s.*:)/g, lang: 'python' },
          { pattern: /(?:public\s|private\s|protected\s|class\s|interface\s|import\s|package\s)/g, lang: 'java' },
          { pattern: /(?:#include|int\s|char\s|float\s|double\s|void\s|struct\s)/g, lang: 'cpp' },
          { pattern: /(?:SELECT|FROM|WHERE|INSERT|UPDATE|DELETE|CREATE|DROP)/gi, lang: 'sql' },
          { pattern: /(?:<html|<head|<body|<div|<span|<p>)/gi, lang: 'html' },
          { pattern: /(?:\.|\#)[a-zA-Z][a-zA-Z0-9-]*\s*\{|@media|@import/g, lang: 'css' },
          { pattern: /(?:\$[a-zA-Z_][a-zA-Z0-9_]*|<\?php|\?>|echo\s|print\s)/g, lang: 'php' }
        ];

        for (const { pattern, lang } of langPatterns) {
          if (pattern.test(code)) return lang;
        }

        return 'text';
      }

      function copyToClipboard(text, button) {
        navigator.clipboard.writeText(text).then(() => {
          const originalText = button.textContent;
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
          }, 2000);
          showToast('success', 'Copied', 'Text copied to clipboard successfully.');
        }).catch(err => {
          console.error('Failed to copy:', err);
          button.textContent = 'Failed!';
          setTimeout(() => button.textContent = 'Copy', 2000);
          showToast('error', 'Copy Failed', 'Failed to copy text to clipboard.');
        });
      }

      function parseMessageContent(text) {
        const container = document.createElement('div');
        container.className = 'message-content';
        const parts = text.split(/(```[\s\S]*?```)/g);

        parts.forEach(part => {
          if (part.match(/^```[\s\S]*```$/)) {
            const codeMatch = part.match(/^```(\w*)\n?([\s\S]*?)\n?```$/);
            const language = codeMatch?.[1] || 'text';
            const code = codeMatch?.[2] || part.replace(/^```|```$/g, '');

            const codeBlock = document.createElement('div');
            codeBlock.className = 'code-block';

            const header = document.createElement('div');
            header.className = 'code-block-header';
            header.innerHTML = `<span>${language || 'Code'}</span>`;

            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy Code';
            copyBtn.onclick = (e) => {
              e.stopPropagation();
              copyToClipboard(code, copyBtn);
            };
            header.appendChild(copyBtn);

            const pre = document.createElement('pre');
            const codeElement = document.createElement('code');
            codeElement.textContent = code;

            if (language && hljs.getLanguage(language)) {
              codeElement.className = `language-${language}`;
              hljs.highlightElement(codeElement);
            } else {
              const detectedLang = detectLanguage(code);
              if (detectedLang !== 'text' && hljs.getLanguage(detectedLang)) {
                codeElement.className = `language-${detectedLang}`;
                hljs.highlightElement(codeElement);
              }
            }

            pre.appendChild(codeElement);
            codeBlock.appendChild(header);
            codeBlock.appendChild(pre);
            container.appendChild(codeBlock);
          } else {
            const inlineParts = part.split(/(`[^`]+`)/g);
            inlineParts.forEach(inlinePart => {
              if (inlinePart.match(/^`[^`]+`$/)) {
                const code = inlinePart.slice(1, -1);
                const inlineCode = document.createElement('span');
                inlineCode.className = 'inline-code';
                inlineCode.textContent = code;
                
                const smallCopyBtn = document.createElement('button');
                smallCopyBtn.className = 'copy-btn-small';
                smallCopyBtn.innerHTML = '📋';
                smallCopyBtn.title = 'Copy inline code';
                smallCopyBtn.onclick = (e) => {
                  e.stopPropagation();
                  copyToClipboard(code, smallCopyBtn);
                };
                
                inlineCode.appendChild(smallCopyBtn);
                container.appendChild(inlineCode);
              } else if (inlinePart) {
                container.appendChild(document.createTextNode(inlinePart));
              }
            });
          }
        });

        return container;
      }

      function appendMessage(text, className, isTyping = false, showTimestamp = true, images = []) {
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${className}${isTyping ? ' typing-indicator' : ''}`;
        msgDiv.style.transform = 'translateY(20px)';
        msgDiv.style.opacity = '0';

        if (!isTyping) {
          if (images && images.length > 0 && className === 'user') {
            const imageContainer = document.createElement('div');
            imageContainer.style.marginBottom = '0.5rem';

            images.forEach(img => {
              const imgElement = document.createElement('img');
              imgElement.src = img.dataUrl;
              imgElement.alt = img.name || 'Attached image';
              imgElement.className = 'message-image';
              imgElement.onclick = () => openImageModal(img.dataUrl);
              imageContainer.appendChild(imgElement);
            });

            msgDiv.appendChild(imageContainer);
          }

          const contentDiv = parseMessageContent(text);
          if (className === 'ai') {
            const fullCopyBtn = document.createElement('button');
            fullCopyBtn.className = 'copy-btn-inline';
            fullCopyBtn.textContent = 'Copy All';
            fullCopyBtn.onclick = (e) => {
              e.stopPropagation();
              copyToClipboard(text, fullCopyBtn);
            };
            contentDiv.appendChild(fullCopyBtn);
          }
          msgDiv.appendChild(contentDiv);

          if (showTimestamp && className === 'user') {
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = formatTimestamp();
            msgDiv.appendChild(timestamp);
          }
        }

        chatContainer.appendChild(msgDiv);
        
        requestAnimationFrame(() => {
          msgDiv.style.transform = 'translateY(0)';
          msgDiv.style.opacity = '1';
          msgDiv.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          scrollToBottom();
        });
        
        return msgDiv;
      }

      function updateMessageContent(msgDiv, text) {
        const contentDiv = msgDiv.querySelector('.message-content') || document.createElement('div');
        contentDiv.className = 'message-content';
        msgDiv.innerHTML = '';
        const newContent = parseMessageContent(text);

        const fullCopyBtn = document.createElement('button');
        fullCopyBtn.className = 'copy-btn-inline';
        fullCopyBtn.textContent = 'Copy All';
        fullCopyBtn.onclick = (e) => {
          e.stopPropagation();
          copyToClipboard(text, fullCopyBtn);
        };

        newContent.appendChild(fullCopyBtn);
        msgDiv.appendChild(newContent);
        
        requestAnimationFrame(() => scrollToBottom());
      }

      function scrollToBottom() {
        requestAnimationFrame(() => {
          chatContainer.scrollTo({
            top: chatContainer.scrollHeight,
            behavior: 'smooth'
          });
        });
      }

      // Ultra-optimized AI response streaming
      window.streamAIResponse = async function(prompt, images = []) {
        try {
          if (!prompt && images.length === 0) throw new Error('Please provide a message or attach images');
          if (!currentConversationId) throw new Error('No conversation selected');
          if (!modelSelect.value) throw new Error('No model selected');

          const selectedOption = modelSelect.options[modelSelect.selectedIndex];
          const hasVision = selectedOption.dataset.hasVision === 'true';

          if (images.length > 0 && !hasVision) {
            throw new Error('Selected model does not support image analysis. Please choose a model with 👁️ icon.');
          }

          userInput.disabled = true;
          sendBtn.disabled = true;
          photoBtn.disabled = true;

          const contextualPrompt = buildContextualPrompt(prompt, currentConversationId, images);
          const displayMessage = prompt || (images.length > 0 ? 'Analyze these images' : '');

          const userMessage = {
            role: 'user',
            content: displayMessage,
            timestamp: formatTimestamp(),
            images: images.map(img => ({ dataUrl: img.dataUrl, name: img.name }))
          };
          const currentMessages = conversations.get(currentConversationId) || [];
          currentMessages.push(userMessage);
          conversations.set(currentConversationId, currentMessages);
          appendMessage(displayMessage, 'user', false, true, images);
          await cloudStorage.saveToCloud({
            conversations,
            advancedMemory,
            currentConversationId
          });

          attachedImages = [];
          updateImagePreviews();

          const typingDiv = appendMessage('', 'ai', true, false);
          const selectedModel = modelSelect.value;

          const messages = [];

          const fullHistory = getFullConversationHistory(currentConversationId);
          fullHistory.forEach(msg => {
            messages.push({
              role: msg.role === 'assistant' ? 'assistant' : 'user',
              content: msg.content
            });
          });

          if (images.length > 0) {
            const imageContents = images.map(img => ({
              type: 'image_url',
              image_url: {
                url: img.dataUrl
              }
            }));

            messages.push({
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: contextualPrompt
                },
                ...imageContents
              ]
            });
          } else {
            messages.push({
              role: 'user',
              content: contextualPrompt
            });
          }

          const response = await puter.ai.chat(messages, {
            model: selectedModel,
            stream: true
          });

          typingDiv.remove();

          const aiMsgDiv = document.createElement('div');
          aiMsgDiv.className = 'message ai';
          aiMsgDiv.style.transform = 'translateY(20px)';
          aiMsgDiv.style.opacity = '0';
          chatContainer.appendChild(aiMsgDiv);
          
          requestAnimationFrame(() => {
            aiMsgDiv.style.transform = 'translateY(0)';
            aiMsgDiv.style.opacity = '1';
            aiMsgDiv.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          });
          
          let fullResponse = '';

          for await (const part of response) {
            if (part?.text) {
              fullResponse += part.text;
              updateMessageContent(aiMsgDiv, fullResponse);
            }
          }

          const aiMessage = { role: 'ai', content: fullResponse, timestamp: formatTimestamp() };
          currentMessages.push(aiMessage);
          conversations.set(currentConversationId, currentMessages);

          updateAdvancedMemory(displayMessage, fullResponse, currentConversationId, images);

          await cloudStorage.saveToCloud({
            conversations,
            advancedMemory,
            currentConversationId
          });
          updateConversationSelect();
        } catch (error) {
          console.error('Error:', error);

          const typingIndicators = document.querySelectorAll('.typing-indicator');
          typingIndicators.forEach(indicator => indicator.remove());

          const errorMsg = error.message || 'Something went wrong. Please try again.';
          appendMessage(`Error: ${errorMsg}`, 'ai', false, false);
          showToast('error', 'AI Error', errorMsg);
        } finally {
          userInput.disabled = false;
          sendBtn.disabled = false;
          photoBtn.disabled = false;
          userInput.focus();
        }
      };

      function handleSend() {
        const text = userInput.value.trim();
        if (text || attachedImages.length > 0) {
          const imagesToSend = [...attachedImages];
          streamAIResponse(text, imagesToSend);
          userInput.value = '';
        }
      }

      // Event listeners with performance optimization
      sendBtn.onclick = handleSend;
      userInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !sendBtn.disabled) handleSend();
      });

      photoBtn.onclick = () => fileInput.click();
      fileInput.addEventListener('change', handleImageSelect);

      newConversationBtn.onclick = createNewConversation;
      deleteConversationBtn.onclick = deleteConversation;
      clearMemoryBtn.onclick = clearAdvancedMemory;
      conversationSelect.onchange = () => {
        currentConversationId = conversationSelect.value;
        renderMessages();
      };

      // Enhanced cleanup with performance monitoring
      window.addEventListener('beforeunload', () => {
        if (cloudStorage) {
          cloudStorage.destroy();
        }
        if (keySystem) {
          keySystem.destroy();
        }
      });

      // FIXED: Global functions for UI interaction
      window.toggleKeyPanel = function() {
        const keyDetails = document.getElementById('key-details');
        keyDetails.classList.toggle('show');

        if (keySystem && keySystem.isActivated) {
          keySystem.updateUI();
        }
      };

      window.activateKey = function() {
        const keyInput = document.getElementById('key-input');
        const key = keyInput.value.trim();

        if (!key) {
          showToast('warning', 'Empty Key', 'Please enter an activation key.');
          return;
        }

        if (keySystem) {
          keySystem.activateKey(key);
        }
      };

      // FIXED: Enhanced key input handling
      document.getElementById('key-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          activateKey();
        }
      });

      // FIXED: Initialize all systems with performance tracking
      const initStartTime = performance.now();
      
      populateModelSelector();
      loadConversations().then(() => {
        userInput.focus();
        const initEndTime = performance.now();
        console.log(`FIXED: Complete initialization time: ${(initEndTime - initStartTime).toFixed(2)}ms`);
        console.log('FIXED: Ultra-persistent UID system active - authentication will NEVER reset unless browser data explicitly cleared');
        console.log('FIXED: Enhanced IndexedDB + localStorage redundancy ensures maximum persistence');
        console.log('FIXED: Real-time monitoring provides instant blocking with zero latency');
      });
    }

    // FIXED: Start ultra-optimized initialization
    initializeApp();
  </script>
</body>
</html>